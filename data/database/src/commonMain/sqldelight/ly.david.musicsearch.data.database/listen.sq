import kotlin.String;
import kotlin.collections.List;

-- Primary key considerations:
-- An autoincrementing id may let unintended duplicates through if the user doesn't fetch all their listens in one go.
-- With manual submission in ListenBrainz, it is possible to have the same listened_at for multiple listens.
-- But ListenBrainz doesn't allow the same recording to be listened at the same time by the same user: https://github.com/metabrainz/listenbrainz-server/blob/e18111661afaf18834dfce4e138e380e674564cd/admin/timescale/create_indexes.sql#L5
CREATE TABLE listen (
  inserted_at_ms INTEGER NOT NULL,
  listened_at_ms INTEGER NOT NULL,
  recording_messybrainz_id TEXT NOT NULL,
  username TEXT NOT NULL,

  recording_musicbrainz_id TEXT NOT NULL,
  release_mbid TEXT,
  caa_id INTEGER,
  caa_release_mbid TEXT,

  -- These are required fields when submitting listens to ListenBrainz.
  -- We will use them as fallback when there are no mappings to a MusicBrainz recording
  -- to get its name and artist credits
  artist_name TEXT NOT NULL,
  track_name TEXT NOT NULL,

  release_name TEXT,

  duration_ms INTEGER,
  media_player TEXT,
  submission_client TEXT,
  music_service TEXT,
  music_service_name TEXT,
  origin_url TEXT,

  spotify_album_artist_ids TEXT AS List<String>,
  spotify_album_id TEXT,
  spotify_artist_ids TEXT AS List<String>,
  spotify_id TEXT,

  PRIMARY KEY (listened_at_ms, username, recording_messybrainz_id)
);

CREATE INDEX idx_listen_username_recording_mbid ON listen (username, recording_musicbrainz_id);
CREATE INDEX idx_listen_caa_release_mbid ON listen (caa_release_mbid);

-- queries

insert:
INSERT OR IGNORE INTO listen
VALUES ?;

updateListensRecordingId:
UPDATE listen
SET recording_musicbrainz_id = :newId
WHERE recording_musicbrainz_id = :oldId;

updateMetadata:
UPDATE listen
SET
  recording_musicbrainz_id = :recording_musicbrainz_id,
  release_mbid = :release_mbid,
  caa_id = :caa_id,
  caa_release_mbid = :caa_release_mbid,
  release_name = :release_name,
  duration_ms = :duration_ms
WHERE recording_messybrainz_id = :recording_messybrainz_id;

deleteByUser:
DELETE FROM listen
WHERE listen.username = :username;

getLatestTimestampByUser:
SELECT MAX(listened_at_ms) AS timestamp
FROM listen
WHERE listen.username = :username;

getOldestTimestampByUser:
SELECT MIN(listened_at_ms) AS timestamp
FROM listen
WHERE listen.username = :username;

getUnfilteredCountOfListensByUser:
SELECT COUNT(*)
FROM listen
WHERE listen.username = :username;

getCountOfListensByUser:
SELECT COUNT(*)
FROM (
  SELECT DISTINCT listened_at_ms, username, recording_messybrainz_id
  FROM listen
  LEFT JOIN artist_credit_entity ON artist_credit_entity.entity_id = listen.recording_musicbrainz_id
  LEFT JOIN artist_credit ON artist_credit.id = artist_credit_entity.artist_credit_id
  LEFT JOIN artist_credit_name ON artist_credit_name.artist_credit_id = artist_credit.id
  LEFT JOIN recording ON recording.id = listen.recording_musicbrainz_id
  LEFT JOIN recording_alias ON listen.recording_musicbrainz_id = recording_alias.recording_id
    AND recording_alias.is_primary
  LEFT JOIN track ON track.recording_id = recording.id
  LEFT JOIN medium ON medium.id = track.medium_id
  LEFT JOIN `release` ON `release`.id = medium.release_id
  LEFT JOIN release_alias ON release_alias.release_id = `release`.id
    AND release_alias.is_primary
  WHERE listen.username = :username
  AND CASE
    WHEN :recordingId IS NULL THEN 1
    ELSE recording_musicbrainz_id = :recordingId
  END
  AND CASE
    WHEN :releaseId IS NULL THEN 1
    ELSE COALESCE(`release`.id, '') = :releaseId
  END
  AND CASE
    WHEN :artistId IS NULL THEN 1
    ELSE COALESCE(artist_credit_name.artist_id, '') = :artistId
  END
  AND (
    recording.name LIKE :query OR
    recording.disambiguation LIKE :query OR
    recording_alias.name LIKE :query OR
    listen.track_name LIKE :query OR
    artist_credit.name LIKE :query OR
    listen.artist_name LIKE :query OR
    listen.release_name LIKE :query OR
    release.name LIKE :query OR
    release.disambiguation LIKE :query OR
    release_alias.name LIKE :query
  )
);

getListensByUser:
SELECT
  listen.listened_at_ms,
  listen.recording_messybrainz_id,
  listen.username,
  listen.recording_musicbrainz_id,
  recording.name AS recordingName,
  recording.disambiguation,
  listen.track_name AS fallbackName,
  listen.duration_ms,
  artist_credit.name AS artistCreditNames,
  listen.artist_name AS fallbackArtistCreditNames,
  listen.release_name,
  COALESCE(listen.release_mbid, listen.caa_release_mbid) AS releaseId,
  mi.thumbnail_url,
  mi.id AS imageId,
  EXISTS (
    SELECT 1 FROM details_metadata
    WHERE details_metadata.entity_id = listen.recording_musicbrainz_id
  ) AS visitedRecording,
  EXISTS (
    SELECT 1 FROM details_metadata
    WHERE details_metadata.entity_id = COALESCE(listen.release_mbid, listen.caa_release_mbid)
  ) AS visitedRelease,
  GROUP_CONCAT(recording_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(recording_alias.locale, CHAR(9)) AS alias_locales
FROM listen
LEFT JOIN artist_credit_entity ON artist_credit_entity.entity_id = listen.recording_musicbrainz_id
LEFT JOIN artist_credit ON artist_credit.id = artist_credit_entity.artist_credit_id
LEFT JOIN artist_credit_name ON artist_credit_name.artist_credit_id = artist_credit.id
LEFT JOIN recording ON recording.id = listen.recording_musicbrainz_id
LEFT JOIN recording_alias ON listen.recording_musicbrainz_id = recording_alias.recording_id
  AND recording_alias.is_primary
LEFT JOIN track ON track.recording_id = recording.id
LEFT JOIN medium ON medium.id = track.medium_id
LEFT JOIN `release` ON `release`.id = medium.release_id
LEFT JOIN release_alias ON release_alias.release_id = `release`.id
  AND release_alias.is_primary
LEFT JOIN mbid_image mi ON mi.mbid = listen.caa_release_mbid
WHERE listen.username = :username
AND CASE
  WHEN :recordingId IS NULL THEN 1
  ELSE recording_musicbrainz_id = :recordingId
END
AND CASE
  WHEN :releaseId IS NULL THEN 1
  ELSE COALESCE(`release`.id, '') = :releaseId
END
AND CASE
  WHEN :artistId IS NULL THEN 1
  ELSE COALESCE(artist_credit_name.artist_id, '') = :artistId
END
AND (
  recording.name LIKE :query OR
  recording.disambiguation LIKE :query OR
  recording_alias.name LIKE :query OR
  listen.track_name LIKE :query OR
  artist_credit.name LIKE :query OR
  listen.artist_name LIKE :query OR
  listen.release_name LIKE :query OR
  release.name LIKE :query OR
  release.disambiguation LIKE :query OR
  release_alias.name LIKE :query
)
GROUP BY listened_at_ms, username, recording_messybrainz_id
ORDER BY listened_at_ms DESC
LIMIT :limit OFFSET :offset;

getCountOfRecordingFacets:
SELECT COUNT(*)
FROM (
  SELECT *
  FROM listen
  LEFT JOIN recording ON recording.id = listen.recording_musicbrainz_id
  LEFT JOIN artist_credit_entity ON artist_credit_entity.entity_id = listen.recording_musicbrainz_id
  LEFT JOIN artist_credit ON artist_credit.id = artist_credit_entity.artist_credit_id
  LEFT JOIN recording_alias ON listen.recording_musicbrainz_id = recording_alias.recording_id
    AND recording_alias.is_primary
  WHERE listen.username = :username
  AND (
    recording.name LIKE :query OR
    recording.disambiguation LIKE :query OR
    recording_alias.name LIKE :query OR
    track_name LIKE :query OR
    recording.disambiguation LIKE :query OR
    artist_credit.name LIKE :query OR
    artist_name LIKE :query OR
    release_name LIKE :query
  )
  GROUP BY listen.recording_musicbrainz_id
);

getRecordingFacets:
SELECT
  listen.recording_musicbrainz_id,
  recording.name AS recordingName,
  recording.disambiguation,
  artist_credit.name AS artistCreditNames,
  GROUP_CONCAT(recording_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(recording_alias.locale, CHAR(9)) AS alias_locales,
  COUNT(*)
FROM listen
LEFT JOIN recording ON recording.id = listen.recording_musicbrainz_id
LEFT JOIN artist_credit_entity ON artist_credit_entity.entity_id = listen.recording_musicbrainz_id
LEFT JOIN artist_credit ON artist_credit.id = artist_credit_entity.artist_credit_id
LEFT JOIN recording_alias ON listen.recording_musicbrainz_id = recording_alias.recording_id
  AND recording_alias.is_primary
WHERE listen.username = :username
AND (
  recording.name LIKE :query OR
  recording.disambiguation LIKE :query OR
  recording_alias.name LIKE :query OR
  track_name LIKE :query OR
  recording.disambiguation LIKE :query OR
  artist_credit.name LIKE :query OR
  artist_name LIKE :query OR
  release_name LIKE :query
)
GROUP BY listen.recording_musicbrainz_id
ORDER BY COUNT(*) DESC
LIMIT :limit OFFSET :offset;

getCountOfReleaseFacets:
SELECT COUNT(*)
FROM (
  SELECT release_info.release_id
  FROM (
    SELECT DISTINCT
      listen.listened_at_ms,
      listen.recording_messybrainz_id,
      listen.username,
      COALESCE(`release`.id, '') AS release_id,
      COALESCE(`release`.name, listen.release_name) AS release_name,
      `release`.disambiguation AS release_disambiguation,
      COALESCE(artist_credit.name, listen.artist_name) AS artistCreditNames
    FROM listen
    LEFT JOIN recording ON recording.id = listen.recording_musicbrainz_id
    LEFT JOIN track ON track.recording_id = recording.id
    LEFT JOIN medium ON medium.id = track.medium_id
    LEFT JOIN `release` ON `release`.id = medium.release_id
    LEFT JOIN artist_credit_entity ON artist_credit_entity.entity_id = `release`.id
    LEFT JOIN artist_credit ON artist_credit.id = artist_credit_entity.artist_credit_id
    WHERE listen.username = :username
  ) AS release_info
  LEFT JOIN (
    SELECT
      release_alias.release_id,
      GROUP_CONCAT(release_alias.name, CHAR(9)) AS alias_names,
      GROUP_CONCAT(release_alias.locale, CHAR(9)) AS alias_locales
    FROM release_alias
    WHERE release_alias.is_primary AND release_alias.release_id IN (
      SELECT DISTINCT `release`.id
      FROM listen
      LEFT JOIN recording ON recording.id = listen.recording_musicbrainz_id
      LEFT JOIN track ON track.recording_id = recording.id
      LEFT JOIN medium ON medium.id = track.medium_id
      LEFT JOIN `release` ON `release`.id = medium.release_id
      WHERE listen.username = :username
      AND `release`.id IS NOT NULL
    )
    GROUP BY release_alias.release_id
  ) AS aliases ON aliases.release_id = release_info.release_id
  WHERE (
    release_info.release_name LIKE :query OR
    release_info.release_disambiguation LIKE :query OR
    release_info.artistCreditNames LIKE :query OR
    aliases.alias_names LIKE :query OR
    aliases.alias_locales LIKE :query
  )
  GROUP BY release_info.release_id
);

-- These are not from the release id attached to the listen because we want to be able to
-- filter on all listens for any given release.
getReleaseFacets:
SELECT
  release_info.release_id,
  release_info.release_name,
  release_info.release_disambiguation,
  release_info.artistCreditNames,
  aliases.alias_names,
  aliases.alias_locales,
  COUNT(*) AS listen_count
FROM (
  SELECT DISTINCT
    listen.listened_at_ms,
    listen.recording_messybrainz_id,
    listen.username,
    COALESCE(`release`.id, '') AS release_id,
    COALESCE(`release`.name, listen.release_name) AS release_name,
    `release`.disambiguation AS release_disambiguation,
    COALESCE(artist_credit.name, listen.artist_name) AS artistCreditNames
  FROM listen
  LEFT JOIN recording ON recording.id = listen.recording_musicbrainz_id
  LEFT JOIN track ON track.recording_id = recording.id
  LEFT JOIN medium ON medium.id = track.medium_id
  LEFT JOIN `release` ON `release`.id = medium.release_id
  LEFT JOIN artist_credit_entity ON artist_credit_entity.entity_id = `release`.id
  LEFT JOIN artist_credit ON artist_credit.id = artist_credit_entity.artist_credit_id
  WHERE listen.username = :username
) AS release_info
LEFT JOIN (
  SELECT
    release_alias.release_id,
    GROUP_CONCAT(release_alias.name, CHAR(9)) AS alias_names,
    GROUP_CONCAT(release_alias.locale, CHAR(9)) AS alias_locales
  FROM release_alias
  WHERE release_alias.is_primary AND release_alias.release_id IN (
    SELECT DISTINCT `release`.id
    FROM listen
    LEFT JOIN recording ON recording.id = listen.recording_musicbrainz_id
    LEFT JOIN track ON track.recording_id = recording.id
    LEFT JOIN medium ON medium.id = track.medium_id
    LEFT JOIN `release` ON `release`.id = medium.release_id
    WHERE listen.username = :username
    AND `release`.id IS NOT NULL
  )
  GROUP BY release_alias.release_id
) AS aliases ON aliases.release_id = release_info.release_id
WHERE (
  release_info.release_name LIKE :query OR
  release_info.release_disambiguation LIKE :query OR
  release_info.artistCreditNames LIKE :query OR
  aliases.alias_names LIKE :query OR
  aliases.alias_locales LIKE :query
)
GROUP BY release_info.release_id
ORDER BY COUNT(*) DESC
LIMIT :limit OFFSET :offset;

getCountOfArtistFacets:
SELECT COUNT(*)
FROM (
  SELECT artist_info.artist_id
  FROM (
    SELECT DISTINCT
      listen.listened_at_ms,
      listen.recording_messybrainz_id,
      listen.username,
      COALESCE(artist_credit_name.artist_id, '') AS artist_id,
      COALESCE(artist.name, artist_credit_name.name) AS name,
      artist.disambiguation AS disambiguation
    FROM listen
    LEFT JOIN recording ON recording.id = listen.recording_musicbrainz_id
    LEFT JOIN artist_credit_entity ON artist_credit_entity.entity_id = recording.id
    LEFT JOIN artist_credit_name ON artist_credit_name.artist_credit_id = artist_credit_entity.artist_credit_id
    LEFT JOIN artist ON artist.id = artist_credit_name.artist_id
    WHERE listen.username = :username
  ) AS artist_info
  LEFT JOIN (
    SELECT
      artist_alias.artist_id,
      GROUP_CONCAT(artist_alias.name, CHAR(9)) AS alias_names,
      GROUP_CONCAT(artist_alias.locale, CHAR(9)) AS alias_locales
    FROM artist_alias
    WHERE artist_alias.is_primary AND artist_alias.artist_id IN (
      SELECT DISTINCT artist.id
      FROM listen
      LEFT JOIN recording ON recording.id = listen.recording_musicbrainz_id
      LEFT JOIN artist_credit_entity ON artist_credit_entity.entity_id = recording.id
      LEFT JOIN artist_credit_name ON artist_credit_name.artist_credit_id = artist_credit_entity.artist_credit_id
      LEFT JOIN artist ON artist.id = artist_credit_name.artist_id
      WHERE listen.username = :username
      AND artist.id IS NOT NULL
    )
    GROUP BY artist_alias.artist_id
  ) AS aliases ON aliases.artist_id = artist_info.artist_id
  WHERE (
    artist_info.name LIKE :query OR
    artist_info.disambiguation LIKE :query OR
    aliases.alias_names LIKE :query OR
    aliases.alias_locales LIKE :query
  )
  GROUP BY artist_info.artist_id
);

getArtistFacets:
SELECT
  artist_info.artist_id,
  artist_info.name,
  artist_info.disambiguation,
  aliases.alias_names,
  aliases.alias_locales,
  COUNT(*) AS listen_count
FROM (
  SELECT DISTINCT
    listen.listened_at_ms,
    listen.recording_messybrainz_id,
    listen.username,
    COALESCE(artist_credit_name.artist_id, '') AS artist_id,
    COALESCE(artist.name, artist_credit_name.name) AS name,
    artist.disambiguation AS disambiguation
  FROM listen
  LEFT JOIN recording ON recording.id = listen.recording_musicbrainz_id
  LEFT JOIN artist_credit_entity ON artist_credit_entity.entity_id = recording.id
  LEFT JOIN artist_credit_name ON artist_credit_name.artist_credit_id = artist_credit_entity.artist_credit_id
  LEFT JOIN artist ON artist.id = artist_credit_name.artist_id
  WHERE listen.username = :username
) AS artist_info
LEFT JOIN (
  SELECT
    artist_alias.artist_id,
    GROUP_CONCAT(artist_alias.name, CHAR(9)) AS alias_names,
    GROUP_CONCAT(artist_alias.locale, CHAR(9)) AS alias_locales
  FROM artist_alias
  WHERE artist_alias.is_primary AND artist_alias.artist_id IN (
    SELECT DISTINCT artist.id
    FROM listen
    LEFT JOIN recording ON recording.id = listen.recording_musicbrainz_id
    LEFT JOIN artist_credit_entity ON artist_credit_entity.entity_id = recording.id
    LEFT JOIN artist_credit_name ON artist_credit_name.artist_credit_id = artist_credit_entity.artist_credit_id
    LEFT JOIN artist ON artist.id = artist_credit_name.artist_id
    WHERE listen.username = :username
    AND artist.id IS NOT NULL
  )
  GROUP BY artist_alias.artist_id
) AS aliases ON aliases.artist_id = artist_info.artist_id
WHERE (
  artist_info.name LIKE :query OR
  artist_info.disambiguation LIKE :query OR
  aliases.alias_names LIKE :query OR
  aliases.alias_locales LIKE :query
)
GROUP BY artist_info.artist_id
ORDER BY COUNT(*) DESC
LIMIT :limit OFFSET :offset;
