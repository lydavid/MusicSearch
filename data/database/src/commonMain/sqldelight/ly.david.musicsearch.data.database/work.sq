import kotlin.String;
import kotlin.collections.List;

CREATE TABLE IF NOT EXISTS work (
  id TEXT PRIMARY KEY NOT NULL,
  name TEXT NOT NULL,
  disambiguation TEXT,
  type TEXT,
  type_id TEXT,
  language TEXT,
  iswcs TEXT AS List<String>
);

insertWork:
INSERT OR IGNORE INTO work
VALUES ?;

getWork:
SELECT
  id,
  name,
  disambiguation,
  type,
  language,
  iswcs
FROM work WHERE id = ?;

deleteWork:
DELETE FROM work
WHERE id = :id;

-- works by entity

CREATE TABLE IF NOT EXISTS works_by_entity (
  entity_id TEXT NOT NULL,
  work_id TEXT NOT NULL,

  PRIMARY KEY (entity_id, work_id)
);

insertOrIgnoreWorkByEntity:
INSERT OR IGNORE INTO works_by_entity
VALUES ?;

deleteWorksByEntity {
WITH
  works_linked_to_multiple_entities AS (
    SELECT work_id
    FROM works_by_entity
    GROUP BY work_id
    HAVING COUNT(DISTINCT entity_id) > 1
  ),
  works_to_delete AS (
    SELECT w.id
    FROM work w
    INNER JOIN works_by_entity we ON w.id = we.work_id
    WHERE we.entity_id = :entityId
    AND w.id NOT IN (SELECT work_id FROM works_linked_to_multiple_entities)
  )
DELETE FROM work
WHERE id IN (SELECT id FROM works_to_delete);

DELETE FROM works_by_entity WHERE entity_id = :entityId;
}

getNumberOfWorksByEntity:
SELECT IFNULL(
  (
    SELECT COUNT(*)
    FROM works_by_entity we
    INNER JOIN work w ON w.id = we.work_id
    WHERE we.entity_id = :entityId
    AND (
      w.name LIKE :query
      OR w.disambiguation LIKE :query
      OR w.type LIKE :query
      OR w.language LIKE :query
      OR w.iswcs LIKE :query
    )
  ),
  0
) AS count;

getWorksByEntity:
SELECT
  w.id,
  w.name,
  w.disambiguation,
  w.type,
  w.language,
  w.iswcs,
  visited.entity_id IS NOT NULL AS visited
FROM works_by_entity we
INNER JOIN work w ON w.id = we.work_id
LEFT JOIN visited ON visited.entity_id = w.id
WHERE we.entity_id = :entityId
AND (
  w.name LIKE :query
  OR w.disambiguation LIKE :query
  OR w.type LIKE :query
  OR w.language LIKE :query
  OR w.iswcs LIKE :query
)
LIMIT :limit OFFSET :offset;
