import kotlin.String;
import kotlin.collections.List;

CREATE TABLE work (
  id TEXT PRIMARY KEY NOT NULL,
  name TEXT NOT NULL,
  disambiguation TEXT NOT NULL,
  type TEXT NOT NULL,
  type_id TEXT NOT NULL,
  iswcs TEXT AS List<String> NOT NULL,
  languages TEXT AS List<String> NOT NULL
);

upsert {
UPDATE work
SET
  name = :name,
  disambiguation = :disambiguation,
  type = :type,
  type_id = :typeId,
  iswcs = :iswcs,
  languages = :languages
WHERE id = :id;

INSERT OR IGNORE INTO work
VALUES (
  :id,
  :name,
  :disambiguation,
  :type,
  :typeId,
  :iswcs,
  :languages
);
}

getWorkForDetails:
SELECT
  work.id,
  work.name,
  work.disambiguation,
  work.type,
  work.languages,
  work.iswcs,
  details_metadata.last_updated,
  COUNT(listen.recording_musicbrainz_id)
FROM work
LEFT JOIN details_metadata ON details_metadata.entity_id = id
LEFT JOIN relation ON work.id = relation.entity_id
LEFT JOIN listen ON listen.recording_musicbrainz_id = relation.linked_entity_id AND listen.username = :username
WHERE work.id = :workId;

getLatestListensByWork:
SELECT
  listened_at_ms
FROM work
LEFT JOIN relation ON work.id = relation.entity_id
LEFT JOIN listen ON listen.recording_musicbrainz_id = relation.linked_entity_id AND listen.username = :username
WHERE work.id = :workId
ORDER BY listened_at_ms DESC
LIMIT COALESCE(:limit, -1);

deleteWork:
DELETE FROM work
WHERE id = :id;

-- works by entity

CREATE TABLE IF NOT EXISTS works_by_entity (
  entity_id TEXT NOT NULL,
  work_id TEXT NOT NULL,

  PRIMARY KEY (entity_id, work_id)
);

insertOrIgnoreWorkByEntity:
INSERT OR IGNORE INTO works_by_entity
VALUES ?;

deleteWorkLinksByEntity {
DELETE FROM works_by_entity WHERE entity_id = :entityId;
}

getNumberOfWorksByEntity:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT work.id)
    FROM works_by_entity we
    INNER JOIN work ON work.id = we.work_id
    LEFT JOIN work_alias ON work.id = work_alias.work_id AND work_alias.is_primary
    WHERE we.entity_id = :entityId
    AND (
      work.name LIKE :query OR
      work.disambiguation LIKE :query OR
      work.type LIKE :query OR
      work.languages LIKE :query OR
      work.iswcs LIKE :query OR
      work_alias.name LIKE :query
    )
  ),
  0
) AS count;

getWorksByEntity:
SELECT
  work.id,
  work.name,
  work.disambiguation,
  work.type,
  work.languages,
  work.iswcs,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = work.id
  ) AS collected,
  aliases.alias_names,
  aliases.alias_locales,
  CASE
    WHEN :username = '' THEN
      CAST(NULL AS INTEGER)
    WHEN details_metadata.entity_id IS NULL THEN
      -1
    ELSE
      COUNT(listen.recording_musicbrainz_id)
  END AS listen_count
FROM works_by_entity we
INNER JOIN work ON work.id = we.work_id
LEFT JOIN (
  SELECT
    work_alias.work_id,
    GROUP_CONCAT(work_alias.name, CHAR(9)) AS alias_names,
    GROUP_CONCAT(work_alias.locale, CHAR(9)) AS alias_locales
  FROM work_alias
  WHERE work_alias.is_primary AND work_alias.work_id IN (
    SELECT work.id
    FROM work
    INNER JOIN works_by_entity ON work.id = works_by_entity.work_id
    WHERE works_by_entity.entity_id = :entityId
  )
  GROUP BY work_alias.work_id
) AS aliases ON aliases.work_id = work.id
LEFT JOIN details_metadata ON details_metadata.entity_id = work.id
LEFT JOIN relation ON work.id = relation.entity_id
LEFT JOIN listen ON listen.recording_musicbrainz_id = relation.linked_entity_id AND listen.username = :username
WHERE we.entity_id = :entityId
AND (
  work.name LIKE :query OR
  work.disambiguation LIKE :query OR
  work.type LIKE :query OR
  work.languages LIKE :query OR
  work.iswcs LIKE :query OR
  aliases.alias_names LIKE :query
)
GROUP BY work.id
LIMIT :limit OFFSET :offset;

-- works by collection

getNumberOfWorksByCollection:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT work.id)
    FROM work
    INNER JOIN collection_entity ce ON work.id = ce.entity_id
    INNER JOIN collection c ON c.id = ce.id
    LEFT JOIN work_alias ON work.id = work_alias.work_id AND work_alias.is_primary
    WHERE c.id = :collectionId
    AND ce.deleted = 0
    AND (
      work.name LIKE :query OR
      work.disambiguation LIKE :query OR
      work.type LIKE :query OR
      work.languages LIKE :query OR
      work.iswcs LIKE :query OR
      work_alias.name LIKE :query
    )
  ),
  0
) AS count;

getWorksByCollection:
SELECT
  work.id,
  work.name,
  work.disambiguation,
  work.type,
  work.languages,
  work.iswcs,
  details_metadata.entity_id IS NOT NULL AS visited,
  ce.id IS NOT NULL AS collected,
  aliases.alias_names,
  aliases.alias_locales,
  CASE
    WHEN :username = '' THEN
      CAST(NULL AS INTEGER)
    WHEN details_metadata.entity_id IS NULL THEN
      -1
    ELSE
      COUNT(listen.recording_musicbrainz_id)
  END AS listen_count
FROM work
INNER JOIN collection_entity ce ON work.id = ce.entity_id
INNER JOIN collection c ON c.id = ce.id
LEFT JOIN (
  SELECT
    work_alias.work_id,
    GROUP_CONCAT(work_alias.name, CHAR(9)) AS alias_names,
    GROUP_CONCAT(work_alias.locale, CHAR(9)) AS alias_locales
  FROM work_alias
  WHERE work_alias.is_primary AND work_alias.work_id IN (
    SELECT work.id
    FROM work
    INNER JOIN collection_entity ON work.id = collection_entity.entity_id
    WHERE collection_entity.id = :collectionId
  )
  GROUP BY work_alias.work_id
) AS aliases ON aliases.work_id = work.id
LEFT JOIN details_metadata ON details_metadata.entity_id = work.id
LEFT JOIN relation ON work.id = relation.entity_id
LEFT JOIN listen ON listen.recording_musicbrainz_id = relation.linked_entity_id AND listen.username = :username
WHERE c.id = :collectionId
AND ce.deleted = 0
AND (
  work.name LIKE :query OR
  work.disambiguation LIKE :query OR
  work.type LIKE :query OR
  work.languages LIKE :query OR
  work.iswcs LIKE :query OR
  aliases.alias_names LIKE :query
)
GROUP BY work.id
LIMIT :limit OFFSET :offset;

-- all works

getCountOfAllWorks:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT work.id)
    FROM work
    LEFT JOIN work_alias ON work.id = work_alias.work_id AND work_alias.is_primary
    WHERE (
      work.name LIKE :query OR
      work.disambiguation LIKE :query OR
      work.type LIKE :query OR
      work.languages LIKE :query OR
      work.iswcs LIKE :query OR
      work_alias.name LIKE :query
    )
  ),
  0
) AS count;

getAllWorks:
SELECT
  work.id,
  work.name,
  work.disambiguation,
  work.type,
  work.languages,
  work.iswcs,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = work.id
  ) AS collected,
  aliases.alias_names,
  aliases.alias_locales,
  CASE
    WHEN :username = '' THEN
      CAST(NULL AS INTEGER)
    WHEN details_metadata.entity_id IS NULL THEN
      -1
    ELSE
      COUNT(listen.recording_musicbrainz_id)
  END AS listen_count
FROM work
LEFT JOIN (
  SELECT
    work_alias.work_id,
    GROUP_CONCAT(work_alias.name, CHAR(9)) AS alias_names,
    GROUP_CONCAT(work_alias.locale, CHAR(9)) AS alias_locales
  FROM work_alias
  WHERE work_alias.is_primary
  GROUP BY work_alias.work_id
) AS aliases ON aliases.work_id = work.id
LEFT JOIN details_metadata ON details_metadata.entity_id = work.id
LEFT JOIN relation ON work.id = relation.entity_id
LEFT JOIN listen ON listen.recording_musicbrainz_id = relation.linked_entity_id AND listen.username = :username
WHERE (
  work.name LIKE :query OR
  work.disambiguation LIKE :query OR
  work.type LIKE :query OR
  work.languages LIKE :query OR
  work.iswcs LIKE :query OR
  aliases.alias_names LIKE :query
)
GROUP BY work.id
LIMIT :limit OFFSET :offset;
