import kotlin.Int;
import ly.david.musicsearch.shared.domain.network.MusicBrainzEntityType;

CREATE TABLE IF NOT EXISTS search_result (
  `id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
  `entity_id` TEXT NOT NULL
);

CREATE INDEX idx_search_result_entity_id ON search_result(entity_id);

CREATE TABLE IF NOT EXISTS search_result_metadata (
  `entity` TEXT AS MusicBrainzEntityType NOT NULL,
  `query` TEXT NOT NULL,
  `local_count` INTEGER AS Int,
  `remote_count` INTEGER AS Int,

  PRIMARY KEY(`entity`, `query`)
);

getMetadata:
SELECT *
FROM search_result_metadata;

removeMetadata:
DELETE FROM search_result_metadata;

setMetadata:
INSERT OR REPLACE INTO search_result_metadata (
  entity,
  query,
  local_count,
  remote_count
)
VALUES (
  :entity,
  :query,
  :localCount,
  :remoteCount
);

insert:
INSERT OR IGNORE INTO search_result (
  entity_id
)
VALUES (
  :entity_id
);

removeAll:
DELETE FROM search_result;

getNumberOfSearchResults:
SELECT IFNULL(
  (
    SELECT COUNT(id)
    FROM search_result
  ),
  0
) AS count;

-- areas

getAreaSearchResults:
SELECT
  area.id,
  area.name,
  area.sort_name,
  area.disambiguation,
  area.type,
  area.begin,
  area.end,
  area.ended,
  cc.code,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = area.id
  ) AS collected,
  GROUP_CONCAT(area_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(area_alias.locale, CHAR(9)) AS alias_locales
FROM area
INNER JOIN search_result sr ON area.id = sr.entity_id
LEFT JOIN area_alias ON area.id = area_alias.area_id AND area_alias.is_primary
LEFT JOIN country_code cc ON area.id = cc.area_id
LEFT JOIN details_metadata ON details_metadata.entity_id = area.id
GROUP BY sr.id
ORDER BY sr.id
LIMIT :limit OFFSET :offset;


-- aritsts

getArtistSearchResults:
SELECT
  artist.id,
  artist.name,
  artist.sort_name,
  artist.disambiguation,
  artist.type,
  artist.gender,
  artist.country_code,
  artist.`begin`,
  artist.`end`,
  artist.ended,
  mi.thumbnail_url,
  mi.id AS imageId,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = artist.id
  ) AS collected,
  GROUP_CONCAT(artist_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(artist_alias.locale, CHAR(9)) AS alias_locales
FROM search_result sr
INNER JOIN artist ON sr.entity_id = artist.id
LEFT JOIN artist_alias ON artist.id = artist_alias.artist_id AND artist_alias.is_primary
LEFT JOIN mbid_image mi ON mi.mbid = artist.id
LEFT JOIN details_metadata ON details_metadata.entity_id = artist.id
GROUP BY sr.id
ORDER BY sr.id
LIMIT :limit OFFSET :offset;


-- events

getEventSearchResults:
SELECT
  event.id,
  event.name,
  event.disambiguation,
  event.type,
  event.time,
  event.cancelled,
  event.begin,
  event.end,
  event.ended,
  mi.thumbnail_url,
  mi.id AS imageId,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = event.id
  ) AS collected,
  GROUP_CONCAT(event_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(event_alias.locale, CHAR(9)) AS alias_locales
FROM search_result sr
INNER JOIN event ON sr.entity_id = event.id
LEFT JOIN event_alias ON event.id = event_alias.event_id AND event_alias.is_primary
LEFT JOIN mbid_image mi ON mi.mbid = event.id
LEFT JOIN details_metadata ON details_metadata.entity_id = event.id
GROUP BY sr.id
ORDER BY sr.id
LIMIT :limit OFFSET :offset;


-- instruments

getInstrumentSearchResults:
SELECT
  instrument.id,
  instrument.name,
  instrument.disambiguation,
  instrument.description,
  instrument.type,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = instrument.id
  ) AS collected,
  GROUP_CONCAT(instrument_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(instrument_alias.locale, CHAR(9)) AS alias_locales
FROM search_result sr
INNER JOIN instrument ON sr.entity_id = instrument.id
LEFT JOIN instrument_alias ON instrument.id = instrument_alias.instrument_id AND instrument_alias.is_primary
LEFT JOIN details_metadata ON details_metadata.entity_id = instrument.id
GROUP BY sr.id
ORDER BY sr.id
LIMIT :limit OFFSET :offset;


-- labels

getLabelSearchResults:
SELECT
  label.id,
  label.name,
  label.disambiguation,
  label.type,
  label.label_code,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = label.id
  ) AS collected,
  GROUP_CONCAT(label_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(label_alias.locale, CHAR(9)) AS alias_locales
FROM search_result sr
INNER JOIN label ON sr.entity_id = label.id
LEFT JOIN label_alias ON label.id = label_alias.label_id AND label_alias.is_primary
LEFT JOIN details_metadata ON details_metadata.entity_id = label.id
GROUP BY sr.id
ORDER BY sr.id
LIMIT :limit OFFSET :offset;


-- places

getPlaceSearchResults:
SELECT
  place.id,
  place.name,
  place.disambiguation,
  place.address,
  place.type,
  place.longitude,
  place.latitude,
  place.begin,
  place.end,
  place.ended,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = place.id
  ) AS collected,
  GROUP_CONCAT(place_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(place_alias.locale, CHAR(9)) AS alias_locales
FROM search_result sr
INNER JOIN place ON sr.entity_id = place.id
LEFT JOIN place_alias ON place.id = place_alias.place_id AND place_alias.is_primary
LEFT JOIN details_metadata ON details_metadata.entity_id = place.id
GROUP BY sr.id
ORDER BY sr.id
LIMIT :limit OFFSET :offset;


-- recordings

getRecordingSearchResults:
SELECT
  recording.id,
  recording.name,
  recording.disambiguation,
  recording.first_release_date,
  recording.length,
  recording.video,
  ac.name AS artist_credits,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = recording.id
  ) AS collected,
  GROUP_CONCAT(recording_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(recording_alias.locale, CHAR(9)) AS alias_locales,
  CAST(NULL AS INTEGER) AS listen_count
FROM search_result sr
INNER JOIN recording ON sr.entity_id = recording.id
INNER JOIN artist_credit_entity acr ON acr.entity_id = recording.id
INNER JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN recording_alias ON recording.id = recording_alias.recording_id AND recording_alias.is_primary
LEFT JOIN details_metadata ON details_metadata.entity_id = recording.id
GROUP BY sr.id
ORDER BY sr.id
LIMIT :limit OFFSET :offset;


-- releases

getReleaseSearchResults:
SELECT
  release_base.*,
  CAST(NULL AS INTEGER) AS listen_count,
  0 AS complete_listen_count
FROM search_result sr
INNER JOIN release_base ON sr.entity_id = release_base.id
ORDER BY sr.id
LIMIT :limit OFFSET :offset;


-- release groups

getReleaseGroupSearchResults:
SELECT
  release_group_base.id,
  release_group_base.name,
  release_group_base.disambiguation,
  release_group_base.first_release_date,
  release_group_base.primary_type,
  release_group_base.secondary_types,
  release_group_base.artist_credits,
  release_group_base.thumbnail_url,
  release_group_base.image_id,
  release_group_base.visited,
  release_group_base.collected,
  release_group_base.alias_names,
  release_group_base.alias_locales
FROM search_result sr
INNER JOIN release_group_base ON sr.entity_id = release_group_base.id
ORDER BY sr.id
LIMIT :limit OFFSET :offset;


-- series

getSeriesSearchResults:
SELECT
  series.id,
  series.name,
  series.disambiguation,
  series.type,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = series.id
  ) AS collected,
  GROUP_CONCAT(series_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(series_alias.locale, CHAR(9)) AS alias_locales
FROM search_result sr
INNER JOIN series ON sr.entity_id = series.id
LEFT JOIN series_alias ON series.id = series_alias.series_id AND series_alias.is_primary
LEFT JOIN details_metadata ON details_metadata.entity_id = series.id
GROUP BY sr.id
ORDER BY sr.id
LIMIT :limit OFFSET :offset;


-- work

getWorkSearchResults:
SELECT
  work.id,
  work.name,
  work.disambiguation,
  work.type,
  work.languages,
  work.iswcs,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = work.id
  ) AS collected,
  GROUP_CONCAT(work_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(work_alias.locale, CHAR(9)) AS alias_locales
FROM search_result sr
INNER JOIN work ON sr.entity_id = work.id
LEFT JOIN details_metadata ON details_metadata.entity_id = work.id
LEFT JOIN work_alias ON work.id = work_alias.work_id AND work_alias.is_primary
GROUP BY sr.id
ORDER BY sr.id
LIMIT :limit OFFSET :offset;
