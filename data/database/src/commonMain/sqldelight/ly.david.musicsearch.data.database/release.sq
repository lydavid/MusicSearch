CREATE TABLE "release" (
  id TEXT PRIMARY KEY NOT NULL,
  name TEXT NOT NULL,
  disambiguation TEXT NOT NULL,
  date TEXT NOT NULL,
  barcode TEXT NOT NULL,
  asin TEXT NOT NULL,
  quality TEXT NOT NULL,
  country_code TEXT NOT NULL,
  status_id TEXT NOT NULL,
  packaging TEXT NOT NULL,
  packaging_id TEXT NOT NULL,
  script TEXT NOT NULL,
  language TEXT NOT NULL
);

-- queries

insert:
INSERT OR IGNORE INTO `release`
VALUES (
  :id,
  :name,
  :disambiguation,
  :date,
  :barcode,
  :asin,
  :quality,
  :country_code,
  :status_id,
  :packaging,
  :packaging_id,
  :script,
  :language
);

upsert {
UPDATE `release`
SET
  name = :name,
  disambiguation = :disambiguation,
  date = :date,
  barcode = :barcode,
  asin = :asin,
  quality = :quality,
  country_code = :country_code,
  status_id = :status_id,
  packaging = :packaging,
  packaging_id = :packaging_id,
  script = :script,
  language = :language
WHERE id = :id;

INSERT OR IGNORE INTO `release`
VALUES (
  :id,
  :name,
  :disambiguation,
  :date,
  :barcode,
  :asin,
  :quality,
  :country_code,
  :status_id,
  :packaging,
  :packaging_id,
  :script,
  :language
);
}

deleteRelease:
DELETE FROM `release` WHERE id = :releaseId;

getReleaseForDetails:
SELECT
  `release`.*,
  (
    SELECT SUM(t.length)
    FROM track t
    INNER JOIN medium m ON t.medium_id = m.id
    INNER JOIN `release` r ON m.release_id = r.id
    WHERE r.id = :releaseId
  ) AS releaseLength,
  (
    SELECT COUNT(t.id) > 0
    FROM track t
    INNER JOIN medium m ON t.medium_id = m.id
    INNER JOIN `release` r ON m.release_id = r.id
    WHERE r.id = :releaseId
    AND t.length IS NULL
  ) AS hasNullLength,
  details_metadata.last_updated
FROM `release`
LEFT JOIN details_metadata ON details_metadata.entity_id = `release`.id
WHERE `release`.id = :releaseId
LIMIT 1;

getReleaseFormatTrackCount:
SELECT m.format, COUNT(t.id) AS trackCount
FROM track t
INNER JOIN medium m ON t.medium_id = m.id
INNER JOIN `release` r ON m.release_id = r.id
WHERE r.id = :releaseId
GROUP BY m.id;

-- listens

getListenCountsByRelease:
SELECT
  SUM(track_listen_counts.count) AS total_listens,
  MAX(track_listen_counts.count) AS most_listened_track_count,
  MIN(track_listen_counts.count) AS complete_listen_count
FROM (
  SELECT
    COUNT(listen.recording_musicbrainz_id) AS count
  FROM track
  INNER JOIN medium ON track.medium_id = medium.id
  LEFT JOIN listen ON listen.recording_musicbrainz_id = track.recording_id AND listen.username = :username
  WHERE medium.release_id = :releaseId
  GROUP BY track.id
) AS track_listen_counts;

getLatestListensByRelease:
SELECT
  medium.position,
  track.number,
  track.title,
  listened_at_ms
FROM `release`
INNER JOIN medium ON medium.release_id = `release`.id
INNER JOIN track ON track.medium_id = medium.id
INNER JOIN listen ON listen.recording_musicbrainz_id = track.recording_id AND listen.username = :username
WHERE `release`.id = :releaseId
ORDER BY listened_at_ms DESC
LIMIT COALESCE(:limit, -1);

-- releases by entity

CREATE TABLE IF NOT EXISTS releases_by_entity (
  entity_id TEXT NOT NULL,
  release_id TEXT NOT NULL,

  PRIMARY KEY (entity_id, release_id)
);

insertOrIgnoreReleasesByEntity:
INSERT OR IGNORE INTO releases_by_entity
VALUES ?;

deleteReleaseLinksByEntity {
DELETE FROM releases_by_entity WHERE entity_id = :entityId;
}

-- releases by label

getNumberOfReleasesByLabel:
SELECT IFNULL(
  COUNT(DISTINCT `release`.id),
  0
) AS count
FROM `release`
INNER JOIN releases_by_entity ON releases_by_entity.release_id = `release`.id
LEFT JOIN (
  SELECT
    release_id,
    GROUP_CONCAT(catalog_number, ', ') AS catalog_numbers
  FROM (
    SELECT release_id, catalog_number
    FROM release_label
    WHERE release_label.label_id = :entityId
    GROUP BY release_id, catalog_number
    ORDER BY catalog_number
  ) AS distinct_catalogs
  GROUP BY release_id
) AS catalog_info ON catalog_info.release_id = `release`.id
LEFT JOIN artist_credit_entity acr ON acr.entity_id = `release`.id
LEFT JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN release_alias ON `release`.id = release_alias.release_id AND release_alias.is_primary
WHERE releases_by_entity.entity_id = :entityId
AND (
  `release`.name LIKE :query OR
  `release`.disambiguation LIKE :query OR
  `release`.date LIKE :query OR
  `release`.country_code LIKE :query OR
  catalog_info.catalog_numbers LIKE :query OR
  ac.name LIKE :query OR
  release_alias.name LIKE :query
);

getReleasesByLabel:
SELECT
  `release`.*,
  ac.name AS artist_credit_names,
  images.thumbnail_url,
  images.id AS image_id,
  COALESCE(
    (
      SELECT COUNT(cc.area_id)
      FROM `release` r2
      LEFT JOIN release_country rc ON rc.release_id = r2.id
      LEFT JOIN country_code cc ON cc.area_id = rc.country_id
      WHERE r2.id = `release`.id
    ),
    0
  ) AS release_country_count,
  EXISTS (
    SELECT 1 FROM details_metadata WHERE details_metadata.entity_id = `release`.id
  ) AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = `release`.id
  ) AS collected,
  aliases.alias_names,
  aliases.alias_locales,
  CASE WHEN :username = '' THEN
    CAST(NULL AS INTEGER)
  ELSE
    COALESCE(SUM(track_listen_counts.listen_count), -1)
  END AS total_listen_count,
  COALESCE(MIN(track_listen_counts.listen_count), 0) AS complete_listen_count,
  catalog_info.catalog_numbers
FROM `release`
INNER JOIN releases_by_entity ON `release`.id = releases_by_entity.release_id
LEFT JOIN (
  SELECT
    release_id,
    GROUP_CONCAT(catalog_number, ', ') AS catalog_numbers
  FROM (
    SELECT release_id, catalog_number
    FROM release_label
    WHERE release_label.label_id = :entityId
    GROUP BY release_id, catalog_number
    ORDER BY catalog_number
  ) AS distinct_catalogs
  GROUP BY release_id
) AS catalog_info ON catalog_info.release_id = `release`.id
LEFT JOIN artist_credit_entity acr ON acr.entity_id = `release`.id
LEFT JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN (
  SELECT
    mbid,
    MIN(thumbnail_url) AS thumbnail_url,
    MIN(id) AS id
  FROM mbid_image
  WHERE mbid_image.mbid IN (
    SELECT releases_by_entity.release_id
    FROM releases_by_entity
    WHERE releases_by_entity.entity_id = :entityId
  )
  GROUP BY mbid
) AS images ON images.mbid = `release`.id
LEFT JOIN (
  SELECT
    track.id AS track_id,
    medium.release_id AS release_id,
    COUNT(listen.recording_musicbrainz_id) AS listen_count
  FROM track
  INNER JOIN medium ON track.medium_id = medium.id
  INNER JOIN releases_by_entity ON medium.release_id = releases_by_entity.release_id
  LEFT JOIN listen ON listen.recording_musicbrainz_id = track.recording_id AND listen.username = :username
  WHERE releases_by_entity.entity_id = :entityId
  GROUP BY track_id
) AS track_listen_counts ON track_listen_counts.release_id = `release`.id
LEFT JOIN (
  SELECT
    release_alias.release_id,
    GROUP_CONCAT(release_alias.name, CHAR(9)) AS alias_names,
    GROUP_CONCAT(release_alias.locale, CHAR(9)) AS alias_locales
  FROM release_alias
  WHERE release_alias.is_primary AND release_alias.release_id IN (
    SELECT DISTINCT `release`.id
    FROM `release`
    INNER JOIN releases_by_entity ON `release`.id = releases_by_entity.release_id
    WHERE releases_by_entity.entity_id = :entityId
  )
  GROUP BY release_alias.release_id
) AS aliases ON aliases.release_id = `release`.id
WHERE releases_by_entity.entity_id = :entityId
AND (
  `release`.name LIKE :query OR
  `release`.disambiguation LIKE :query OR
  `release`.date LIKE :query OR
  `release`.country_code LIKE :query OR
  catalog_info.catalog_numbers LIKE :query OR
  artist_credit_names LIKE :query OR
  aliases.alias_names LIKE :query
)
GROUP BY `release`.id
ORDER BY
  CASE :sortBy
    WHEN 0 THEN releases_by_entity.rowid
    WHEN 2 THEN `release`.name
    WHEN 4 THEN `release`.date
    WHEN 6 THEN total_listen_count
    WHEN 8 THEN complete_listen_count
  END ASC,
  CASE :sortBy
    WHEN 1 THEN releases_by_entity.rowid
    WHEN 3 THEN `release`.name
    WHEN 5 THEN `release`.date
    WHEN 7 THEN total_listen_count
    WHEN 9 THEN complete_listen_count
  END DESC,
  `release`.date ASC,
  `release`.name ASC
LIMIT :limit OFFSET :offset;

deleteReleasesByLabelLinks:
DELETE FROM release_label
WHERE label_id = :labelId;

-- releases by collection

getNumberOfReleasesByCollection:
SELECT IFNULL(
  COUNT(DISTINCT `release`.id),
  0
) AS count
FROM `release`
INNER JOIN collection_entity ce ON `release`.id = ce.entity_id
INNER JOIN collection c ON c.id = ce.id
LEFT JOIN artist_credit_entity acr ON acr.entity_id = `release`.id
LEFT JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN release_alias ON `release`.id = release_alias.release_id AND release_alias.is_primary
WHERE c.id = :collectionId
AND ce.deleted = 0
AND (
  `release`.name LIKE :query OR
  `release`.disambiguation LIKE :query OR
  `release`.date LIKE :query OR
  `release`.country_code LIKE :query OR
  ac.name LIKE :query OR
  release_alias.name LIKE :query
);

getReleasesByCollection:
SELECT
  `release`.*,
  ac.name AS artist_credit_names,
  images.thumbnail_url,
  images.id AS image_id,
  COALESCE(
    (
      SELECT COUNT(cc.area_id)
      FROM `release` r2
      LEFT JOIN release_country rc ON rc.release_id = r2.id
      LEFT JOIN country_code cc ON cc.area_id = rc.country_id
      WHERE r2.id = `release`.id
    ),
    0
  ) AS release_country_count,
  EXISTS (
    SELECT 1 FROM details_metadata WHERE details_metadata.entity_id = `release`.id
  ) AS visited,
  1 == 1 AS collected,
  aliases.alias_names,
  aliases.alias_locales,
  CASE WHEN :username = '' THEN
    CAST(NULL AS INTEGER)
  ELSE
    COALESCE(SUM(track_listen_counts.listen_count), -1)
  END AS total_listen_count,
  COALESCE(MIN(track_listen_counts.listen_count), 0) AS complete_listen_count
FROM `release`
INNER JOIN collection_entity ON `release`.id = collection_entity.entity_id
INNER JOIN collection ON collection.id = collection_entity.id
LEFT JOIN artist_credit_entity acr ON acr.entity_id = `release`.id
LEFT JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN (
  SELECT
    mbid,
    MIN(thumbnail_url) AS thumbnail_url,
    MIN(id) AS id
  FROM mbid_image
  WHERE mbid_image.mbid IN (
    SELECT entity_id
    FROM collection_entity
    WHERE id = :collectionId
  )
  GROUP BY mbid
) AS images ON images.mbid = `release`.id
LEFT JOIN (
  SELECT
    track.id AS track_id,
    medium.release_id AS release_id,
    COUNT(listen.recording_musicbrainz_id) AS listen_count
  FROM track
  INNER JOIN medium ON track.medium_id = medium.id
  INNER JOIN collection_entity ON medium.release_id = collection_entity.entity_id
  LEFT JOIN listen ON listen.recording_musicbrainz_id = track.recording_id AND listen.username = :username
  WHERE collection_entity.id = :collectionId
  GROUP BY track_id
) AS track_listen_counts ON track_listen_counts.release_id = `release`.id
LEFT JOIN (
  SELECT
    release_alias.release_id,
    GROUP_CONCAT(release_alias.name, CHAR(9)) AS alias_names,
    GROUP_CONCAT(release_alias.locale, CHAR(9)) AS alias_locales
  FROM release_alias
  WHERE release_alias.is_primary AND release_alias.release_id IN (
    SELECT DISTINCT `release`.id
    FROM `release`
    INNER JOIN collection_entity ON `release`.id = collection_entity.entity_id
    WHERE collection_entity.id = :collectionId
  )
  GROUP BY release_alias.release_id
) AS aliases ON aliases.release_id = `release`.id
WHERE collection.id = :collectionId
AND collection_entity.deleted = 0
AND (
  `release`.name LIKE :query OR
  `release`.disambiguation LIKE :query OR
  `release`.date LIKE :query OR
  `release`.country_code LIKE :query OR
  artist_credit_names LIKE :query OR
  aliases.alias_names LIKE :query
)
GROUP BY `release`.id
ORDER BY
  CASE :sortBy
    WHEN 0 THEN collection_entity.rowid
    WHEN 2 THEN `release`.name
    WHEN 4 THEN `release`.date
    WHEN 6 THEN total_listen_count
    WHEN 8 THEN complete_listen_count
  END ASC,
  CASE :sortBy
    WHEN 1 THEN collection_entity.rowid
    WHEN 3 THEN `release`.name
    WHEN 5 THEN `release`.date
    WHEN 7 THEN total_listen_count
    WHEN 9 THEN complete_listen_count
  END DESC,
  `release`.date ASC,
  `release`.name ASC
LIMIT :limit OFFSET :offset;

-- releases by entity

getNumberOfReleasesByEntity:
SELECT IFNULL(
  COUNT(DISTINCT `release`.id),
  0
) AS count
FROM `release`
INNER JOIN releases_by_entity ON releases_by_entity.release_id = `release`.id
LEFT JOIN artist_credit_entity acr ON acr.entity_id = `release`.id
LEFT JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN release_alias ON `release`.id = release_alias.release_id AND release_alias.is_primary
WHERE releases_by_entity.entity_id = :entityId
AND (
  `release`.name LIKE :query OR
  `release`.disambiguation LIKE :query OR
  `release`.date LIKE :query OR
  `release`.country_code LIKE :query OR
  ac.name LIKE :query OR
  release_alias.name LIKE :query
);

getReleasesByEntity:
SELECT
  `release`.*,
  ac.name AS artist_credit_names,
  images.thumbnail_url,
  images.id AS image_id,
  COALESCE(
    (
      SELECT COUNT(cc.area_id)
      FROM `release` r2
      LEFT JOIN release_country rc ON rc.release_id = r2.id
      LEFT JOIN country_code cc ON cc.area_id = rc.country_id
      WHERE r2.id = `release`.id
    ),
    0
  ) AS release_country_count,
  EXISTS (
    SELECT 1 FROM details_metadata WHERE details_metadata.entity_id = `release`.id
  ) AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = `release`.id
  ) AS collected,
  aliases.alias_names,
  aliases.alias_locales,
  CASE WHEN :username = '' THEN
    CAST(NULL AS INTEGER)
  ELSE
    COALESCE(SUM(track_listen_counts.listen_count), -1)
  END AS total_listen_count, -- should not be named the same as listen_count to prevent name resolution conflicts
  COALESCE(MIN(track_listen_counts.listen_count), 0) AS complete_listen_count
FROM `release`
INNER JOIN releases_by_entity ON `release`.id = releases_by_entity.release_id
LEFT JOIN artist_credit_entity acr ON acr.entity_id = `release`.id
LEFT JOIN artist_credit ac ON ac.id = acr.artist_credit_id
-- necessary to not multiply listens by the number of images
LEFT JOIN (
  SELECT
    mbid,
    MIN(thumbnail_url) AS thumbnail_url,
    MIN(id) AS id
  FROM mbid_image
  WHERE mbid_image.mbid IN (
    SELECT release_id
    FROM releases_by_entity
    WHERE entity_id = :entityId
  )
  GROUP BY mbid
) AS images ON images.mbid = `release`.id
LEFT JOIN (
  SELECT
    track.id AS track_id,
    medium.release_id AS release_id,
    COUNT(listen.recording_musicbrainz_id) AS listen_count
  FROM track
  INNER JOIN medium ON track.medium_id = medium.id
  INNER JOIN releases_by_entity ON medium.release_id = releases_by_entity.release_id
  LEFT JOIN listen ON listen.recording_musicbrainz_id = track.recording_id AND listen.username = :username
  WHERE releases_by_entity.entity_id = :entityId
  GROUP BY track_id
) AS track_listen_counts ON track_listen_counts.release_id = `release`.id
LEFT JOIN (
  SELECT
    release_alias.release_id,
    GROUP_CONCAT(release_alias.name, CHAR(9)) AS alias_names,
    GROUP_CONCAT(release_alias.locale, CHAR(9)) AS alias_locales
  FROM release_alias
  WHERE release_alias.is_primary AND release_alias.release_id IN (
    SELECT DISTINCT `release`.id
    FROM `release`
    INNER JOIN releases_by_entity ON `release`.id = releases_by_entity.release_id
    WHERE releases_by_entity.entity_id = :entityId
  )
  GROUP BY release_alias.release_id
) AS aliases ON aliases.release_id = `release`.id
WHERE releases_by_entity.entity_id = :entityId
AND (
  `release`.name LIKE :query OR
  `release`.disambiguation LIKE :query OR
  `release`.date LIKE :query OR
  `release`.country_code LIKE :query OR
  artist_credit_names LIKE :query OR
  aliases.alias_names LIKE :query
)
GROUP BY `release`.id
ORDER BY
  CASE :sortBy
    WHEN 0 THEN releases_by_entity.rowid
    WHEN 2 THEN `release`.name
    WHEN 4 THEN `release`.date
    WHEN 6 THEN total_listen_count
    WHEN 8 THEN complete_listen_count
  END ASC,
  CASE :sortBy
    WHEN 1 THEN releases_by_entity.rowid
    WHEN 3 THEN `release`.name
    WHEN 5 THEN `release`.date
    WHEN 7 THEN total_listen_count
    WHEN 9 THEN complete_listen_count
  END DESC,
  `release`.date ASC,
  `release`.name ASC
LIMIT :limit OFFSET :offset;

-- all releases

getCountOfAllReleases:
SELECT IFNULL(
  COUNT(DISTINCT `release`.id),
  0
) AS count
FROM `release`
LEFT JOIN artist_credit_entity acr ON acr.entity_id = `release`.id
LEFT JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN release_alias ON `release`.id = release_alias.release_id AND release_alias.is_primary
AND (
  `release`.name LIKE :query OR
  `release`.disambiguation LIKE :query OR
  `release`.date LIKE :query OR
  `release`.country_code LIKE :query OR
  ac.name LIKE :query OR
  release_alias.name LIKE :query
);

-- left join artist credits because we can insert stub releases from browsing listens
-- we still want these to be searchable in all releases
getAllReleases:
SELECT
  `release`.*,
  ac.name AS artist_credit_names,
  images.thumbnail_url,
  images.id AS image_id,
  COALESCE(
    (
      SELECT COUNT(cc.area_id)
      FROM `release` r2
      LEFT JOIN release_country rc ON rc.release_id = r2.id
      LEFT JOIN country_code cc ON cc.area_id = rc.country_id
      WHERE r2.id = `release`.id
    ),
    0
  ) AS release_country_count,
  EXISTS (
    SELECT 1 FROM details_metadata WHERE details_metadata.entity_id = `release`.id
  ) AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = `release`.id
  ) AS collected,
  aliases.alias_names,
  aliases.alias_locales,
  CASE WHEN :username = '' THEN
    CAST(NULL AS INTEGER)
  ELSE
    COALESCE(SUM(track_listen_counts.listen_count), -1)
  END AS total_listen_count,
  COALESCE(MIN(track_listen_counts.listen_count), 0) AS complete_listen_count
FROM `release`
LEFT JOIN artist_credit_entity acr ON acr.entity_id = `release`.id
LEFT JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN (
  SELECT
    mbid,
    MIN(thumbnail_url) AS thumbnail_url,
    MIN(id) AS id
  FROM mbid_image
  GROUP BY mbid
) AS images ON images.mbid = `release`.id
LEFT JOIN (
  SELECT
    track.id AS track_id,
    medium.release_id AS release_id,
    COUNT(listen.recording_musicbrainz_id) AS listen_count
  FROM track
  INNER JOIN medium ON track.medium_id = medium.id
  LEFT JOIN listen ON listen.recording_musicbrainz_id = track.recording_id AND listen.username = :username
  GROUP BY track_id
) AS track_listen_counts ON track_listen_counts.release_id = `release`.id
LEFT JOIN (
  SELECT
    release_alias.release_id,
    GROUP_CONCAT(release_alias.name, CHAR(9)) AS alias_names,
    GROUP_CONCAT(release_alias.locale, CHAR(9)) AS alias_locales
  FROM release_alias
  WHERE release_alias.is_primary
  GROUP BY release_alias.release_id
) AS aliases ON aliases.release_id = `release`.id
WHERE (
  `release`.name LIKE :query OR
  `release`.disambiguation LIKE :query OR
  `release`.date LIKE :query OR
  `release`.country_code LIKE :query OR
  artist_credit_names LIKE :query OR
  aliases.alias_names LIKE :query
)
GROUP BY `release`.id
ORDER BY
  CASE :sortBy
    WHEN 0 THEN `release`.rowid
    WHEN 2 THEN `release`.name
    WHEN 4 THEN `release`.date
    WHEN 6 THEN total_listen_count
    WHEN 8 THEN complete_listen_count
  END ASC,
  CASE :sortBy
    WHEN 1 THEN `release`.rowid
    WHEN 3 THEN `release`.name
    WHEN 5 THEN `release`.date
    WHEN 7 THEN total_listen_count
    WHEN 9 THEN complete_listen_count
  END DESC,
  `release`.date ASC,
  `release`.name ASC
LIMIT :limit OFFSET :offset;
