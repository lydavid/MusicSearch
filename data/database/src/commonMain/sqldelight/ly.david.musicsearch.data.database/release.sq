CREATE TABLE "release" (
  id TEXT PRIMARY KEY NOT NULL,
  name TEXT NOT NULL,
  disambiguation TEXT NOT NULL,
  date TEXT NOT NULL,
  barcode TEXT NOT NULL,
  asin TEXT NOT NULL,
  quality TEXT NOT NULL,
  country_code TEXT NOT NULL,
  status_id TEXT NOT NULL,
  packaging TEXT NOT NULL,
  packaging_id TEXT NOT NULL,
  script TEXT NOT NULL,
  language TEXT NOT NULL
);

-- left join artist credits because we can insert stub releases from browsing listens
-- we still want these to be searchable in all releases
CREATE VIEW release_base AS
SELECT
  `release`.*,
  ac.name AS artist_credit_names,
  mi.thumbnail_url,
  mi.id AS image_id,
  COALESCE(
    (
      SELECT COUNT(cc.area_id)
      FROM `release` r2
      LEFT JOIN release_country rc ON rc.release_id = r2.id
      LEFT JOIN country_code cc ON cc.area_id = rc.country_id
      WHERE r2.id = `release`.id
    ),
    0
  ) AS release_country_count,
  EXISTS (
    SELECT 1 FROM details_metadata WHERE details_metadata.entity_id = `release`.id
  ) AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = `release`.id
  ) AS collected,
  GROUP_CONCAT(release_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(release_alias.locale, CHAR(9)) AS alias_locales
FROM `release`
LEFT JOIN artist_credit_entity acr ON acr.entity_id = `release`.id
LEFT JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN release_alias ON `release`.id = release_alias.release_id AND release_alias.is_primary
LEFT JOIN mbid_image mi ON mi.mbid = `release`.id
LEFT JOIN details_metadata ON details_metadata.entity_id = `release`.id
GROUP BY `release`.id;

-- queries

insert:
INSERT OR IGNORE INTO `release`
VALUES (
  :id,
  :name,
  :disambiguation,
  :date,
  :barcode,
  :asin,
  :quality,
  :country_code,
  :status_id,
  :packaging,
  :packaging_id,
  :script,
  :language
);

upsert {
UPDATE `release`
SET
  name = :name,
  disambiguation = :disambiguation,
  date = :date,
  barcode = :barcode,
  asin = :asin,
  quality = :quality,
  country_code = :country_code,
  status_id = :status_id,
  packaging = :packaging,
  packaging_id = :packaging_id,
  script = :script,
  language = :language
WHERE id = :id;

INSERT OR IGNORE INTO `release`
VALUES (
  :id,
  :name,
  :disambiguation,
  :date,
  :barcode,
  :asin,
  :quality,
  :country_code,
  :status_id,
  :packaging,
  :packaging_id,
  :script,
  :language
);
}

deleteRelease:
DELETE FROM `release` WHERE id = :releaseId;

getReleaseForDetails:
SELECT
  `release`.*,
  (
    SELECT SUM(t.length)
    FROM track t
    INNER JOIN medium m ON t.medium_id = m.id
    INNER JOIN `release` r ON m.release_id = r.id
    WHERE r.id = :releaseId
  ) AS releaseLength,
  (
    SELECT COUNT(t.id) > 0
    FROM track t
    INNER JOIN medium m ON t.medium_id = m.id
    INNER JOIN `release` r ON m.release_id = r.id
    WHERE r.id = :releaseId
    AND t.length IS NULL
  ) AS hasNullLength,
  details_metadata.last_updated
FROM `release`
LEFT JOIN details_metadata ON details_metadata.entity_id = `release`.id
WHERE `release`.id = :releaseId
LIMIT 1;

getReleaseFormatTrackCount:
SELECT m.format, COUNT(t.id) AS trackCount
FROM track t
INNER JOIN medium m ON t.medium_id = m.id
INNER JOIN `release` r ON m.release_id = r.id
WHERE r.id = :releaseId
GROUP BY m.id;

-- listens

getListenCountsByRelease:
SELECT
  SUM(track_listen_counts.count) AS total_listens,
  MAX(track_listen_counts.count) AS most_listened_track_count,
  MIN(track_listen_counts.count) AS complete_listen_count
FROM (
  SELECT
    COUNT(listen.recording_musicbrainz_id) AS count
  FROM track
  INNER JOIN medium ON track.medium_id = medium.id
  LEFT JOIN listen ON listen.recording_musicbrainz_id = track.recording_id AND listen.username = :username
  WHERE medium.release_id = :releaseId
  GROUP BY track.id
) AS track_listen_counts;

getLatestListensByRelease:
SELECT
  medium.position,
  track.number,
  track.title,
  listened_at_ms
FROM `release`
INNER JOIN medium ON medium.release_id = `release`.id
INNER JOIN track ON track.medium_id = medium.id
INNER JOIN listen ON listen.recording_musicbrainz_id = track.recording_id AND listen.username = :username
WHERE `release`.id = :releaseId
ORDER BY listened_at_ms DESC
LIMIT COALESCE(:limit, -1);

-- releases by entity

CREATE TABLE IF NOT EXISTS releases_by_entity (
  entity_id TEXT NOT NULL,
  release_id TEXT NOT NULL,

  PRIMARY KEY (entity_id, release_id)
);

insertOrIgnoreReleasesByEntity:
INSERT OR IGNORE INTO releases_by_entity
VALUES ?;

deleteReleaseLinksByEntity {
DELETE FROM releases_by_entity WHERE entity_id = :entityId;
}

-- releases by label

getNumberOfReleasesByLabel:
SELECT IFNULL(
  COUNT(DISTINCT release_base.id),
  0
) AS count
FROM release_base
INNER JOIN releases_by_entity ON releases_by_entity.release_id = release_base.id
INNER JOIN release_label ON release_label.release_id = release_base.id
WHERE releases_by_entity.entity_id = :labelId
AND (
  release_base.name LIKE :query OR
  release_base.disambiguation LIKE :query OR
  release_base.date LIKE :query OR
  release_base.country_code LIKE :query OR
  release_base.artist_credit_names LIKE :query OR
  release_label.catalog_number LIKE :query OR
  release_base.alias_names LIKE :query
);

getReleasesByLabel:
SELECT
  release_base.*,
  CASE WHEN :username = '' THEN
    CAST(NULL AS INTEGER)
  ELSE
    COALESCE(SUM(track_listen_counts.listen_count), -1)
  END AS listen_count,
  COALESCE(MIN(track_listen_counts.listen_count), 0) AS complete_listen_count,
  CAST (browse_remote_metadata.last_updated AS INTEGER),
  (
    SELECT GROUP_CONCAT(catalog_number, ', ')
    FROM (
      SELECT DISTINCT rl2.catalog_number
      FROM release_label rl2
      WHERE rl2.release_id = release_base.id
      ORDER BY rl2.catalog_number
    ) AS distinct_catalogs
  ) AS catalog_numbers
FROM release_base
INNER JOIN releases_by_entity ON releases_by_entity.release_id = release_base.id
INNER JOIN release_label ON release_base.id = release_label.release_id
LEFT JOIN (
  SELECT
    track.id AS track_id,
    medium.release_id AS release_id,
    COUNT(listen.recording_musicbrainz_id) AS listen_count
  FROM track
  INNER JOIN medium ON track.medium_id = medium.id
  LEFT JOIN listen ON listen.recording_musicbrainz_id = track.recording_id AND listen.username = :username
  GROUP BY track_id
) AS track_listen_counts ON track_listen_counts.release_id = release_base.id
LEFT JOIN browse_remote_metadata ON browse_remote_metadata.entity_id = releases_by_entity.entity_id AND browse_remote_metadata.browse_entity = 'release'
WHERE releases_by_entity.entity_id = :labelId
AND (
  release_base.name LIKE :query OR
  release_base.disambiguation LIKE :query OR
  release_base.date LIKE :query OR
  release_base.country_code LIKE :query OR
  release_base.artist_credit_names LIKE :query OR
  release_label.catalog_number LIKE :query OR
  release_base.alias_names LIKE :query
)
GROUP BY release_base.id
ORDER BY
  CASE WHEN :sorted THEN release_base.date ELSE releases_by_entity.rowid END,
  CASE WHEN :sorted THEN release_base.name END
LIMIT :limit OFFSET :offset;

deleteReleasesByLabelLinks:
DELETE FROM release_label
WHERE label_id = :labelId;

-- releases by collection

getNumberOfReleasesByCollection:
SELECT IFNULL(
  COUNT(DISTINCT release_base.id),
  0
) AS count
FROM release_base
INNER JOIN collection_entity ce ON release_base.id = ce.entity_id
INNER JOIN collection c ON c.id = ce.id
WHERE c.id = :collectionId
AND ce.deleted = 0
AND (
  release_base.name LIKE :query OR
  release_base.disambiguation LIKE :query OR
  release_base.date LIKE :query OR
  release_base.country_code LIKE :query OR
  release_base.artist_credit_names LIKE :query OR
  release_base.alias_names LIKE :query
);

getReleasesByCollection:
SELECT
  release_base.*,
  CASE WHEN :username = '' THEN
    CAST(NULL AS INTEGER)
  ELSE
    COALESCE(SUM(track_listen_counts.listen_count), -1)
  END AS listen_count,
  COALESCE(MIN(track_listen_counts.listen_count), 0) AS complete_listen_count,
  CAST (browse_remote_metadata.last_updated AS INTEGER)
FROM release_base
INNER JOIN collection_entity ce ON release_base.id = ce.entity_id
INNER JOIN collection c ON c.id = ce.id
LEFT JOIN (
  SELECT
    track.id AS track_id,
    medium.release_id AS release_id,
    COUNT(listen.recording_musicbrainz_id) AS listen_count
  FROM track
  INNER JOIN medium ON track.medium_id = medium.id
  LEFT JOIN listen ON listen.recording_musicbrainz_id = track.recording_id AND listen.username = :username
  GROUP BY track_id
) AS track_listen_counts ON track_listen_counts.release_id = release_base.id
LEFT JOIN browse_remote_metadata ON browse_remote_metadata.entity_id = c.id AND browse_remote_metadata.browse_entity = 'release'
WHERE c.id = :collectionId
AND ce.deleted = 0
AND (
  release_base.name LIKE :query OR
  release_base.disambiguation LIKE :query OR
  release_base.date LIKE :query OR
  release_base.country_code LIKE :query OR
  release_base.artist_credit_names LIKE :query OR
  release_base.alias_names LIKE :query
)
GROUP BY release_base.id
ORDER BY
  CASE WHEN :sorted THEN release_base.date ELSE ce.rowid END,
  CASE WHEN :sorted THEN release_base.name END
LIMIT :limit OFFSET :offset;

-- releases by entity

getNumberOfReleasesByEntity:
SELECT IFNULL(
  COUNT(DISTINCT release_base.id),
  0
) AS count
FROM release_base
INNER JOIN releases_by_entity ON releases_by_entity.release_id = release_base.id
WHERE releases_by_entity.entity_id = :entityId
AND (
  release_base.name LIKE :query OR
  release_base.disambiguation LIKE :query OR
  release_base.date LIKE :query OR
  release_base.country_code LIKE :query OR
  release_base.artist_credit_names LIKE :query OR
  release_base.alias_names LIKE :query
);

getReleasesByEntity:
SELECT
  release_base.*,
  CASE WHEN :username = '' THEN
    CAST(NULL AS INTEGER)
  ELSE
    COALESCE(SUM(track_listen_counts.listen_count), -1)
  END AS listen_count,
  COALESCE(MIN(track_listen_counts.listen_count), 0) AS complete_listen_count,
  CAST (browse_remote_metadata.last_updated AS INTEGER)
FROM release_base
INNER JOIN releases_by_entity ON release_base.id = releases_by_entity.release_id
LEFT JOIN (
  SELECT
    track.id AS track_id,
    medium.release_id AS release_id,
    COUNT(listen.recording_musicbrainz_id) AS listen_count
  FROM track
  INNER JOIN medium ON track.medium_id = medium.id
  LEFT JOIN listen ON listen.recording_musicbrainz_id = track.recording_id AND listen.username = :username
  GROUP BY track_id
) AS track_listen_counts ON track_listen_counts.release_id = release_base.id
LEFT JOIN browse_remote_metadata ON browse_remote_metadata.entity_id = releases_by_entity.entity_id AND browse_remote_metadata.browse_entity = 'release'
WHERE releases_by_entity.entity_id = :entityId
AND (
  release_base.name LIKE :query OR
  release_base.disambiguation LIKE :query OR
  release_base.date LIKE :query OR
  release_base.country_code LIKE :query OR
  release_base.artist_credit_names LIKE :query OR
  release_base.alias_names LIKE :query
)
GROUP BY release_base.id
ORDER BY
  CASE WHEN :sorted THEN release_base.date ELSE releases_by_entity.rowid END,
  CASE WHEN :sorted THEN release_base.name END
LIMIT :limit OFFSET :offset;

-- all releases

getCountOfAllReleases:
SELECT IFNULL(
  COUNT(DISTINCT release_base.id),
  0
) AS count
FROM release_base
WHERE (
  release_base.name LIKE :query OR
  release_base.disambiguation LIKE :query OR
  release_base.date LIKE :query OR
  release_base.country_code LIKE :query OR
  release_base.artist_credit_names LIKE :query OR
  release_base.alias_names LIKE :query
);

getAllReleases:
SELECT
  release_base.*,
  CASE WHEN :username = '' THEN
    CAST(NULL AS INTEGER)
  ELSE
    COALESCE(SUM(track_listen_counts.listen_count), -1)
  END AS listen_count,
  COALESCE(MIN(track_listen_counts.listen_count), 0) AS complete_listen_count,
  CAST(NULL AS INTEGER) AS last_updated
FROM release_base
LEFT JOIN (
  SELECT
    track.id AS track_id,
    medium.release_id AS release_id,
    COUNT(listen.recording_musicbrainz_id) AS listen_count
  FROM track
  INNER JOIN medium ON track.medium_id = medium.id
  LEFT JOIN listen ON listen.recording_musicbrainz_id = track.recording_id AND listen.username = :username
  GROUP BY track_id
) AS track_listen_counts ON track_listen_counts.release_id = release_base.id
WHERE (
  release_base.name LIKE :query OR
  release_base.disambiguation LIKE :query OR
  release_base.date LIKE :query OR
  release_base.country_code LIKE :query OR
  release_base.artist_credit_names LIKE :query OR
  release_base.alias_names LIKE :query
)
GROUP BY release_base.id
ORDER BY
  CASE WHEN :sorted THEN release_base.date END,
  CASE WHEN :sorted THEN release_base.name END
LIMIT :limit OFFSET :offset;
