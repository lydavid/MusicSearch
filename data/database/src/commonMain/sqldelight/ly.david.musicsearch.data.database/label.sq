import kotlin.Boolean;
import kotlin.Int;
import kotlin.String;
import kotlin.collections.List;

CREATE TABLE label (
  id TEXT PRIMARY KEY NOT NULL,
  name TEXT NOT NULL,
  disambiguation TEXT NOT NULL,
  type TEXT NOT NULL,
  type_id TEXT NOT NULL,
  label_code INTEGER AS Int,
  ipis TEXT AS List<String> NOT NULL,
  isnis TEXT AS List<String> NOT NULL,
  begin TEXT NOT NULL,
  end TEXT NOT NULL,
  ended INTEGER AS Boolean NOT NULL
);

insertLabel:
INSERT OR IGNORE INTO label
VALUES ?;

getLabelForDetails:
SELECT
  id,
  name,
  disambiguation,
  type,
  label_code,
  ipis,
  isnis,
  begin,
  end,
  ended,
  details_metadata.last_updated
FROM label
LEFT JOIN details_metadata ON details_metadata.entity_id = id
WHERE id = :labelId;

deleteLabel:
DELETE FROM label
WHERE id = :id;

-- labels by entity

CREATE TABLE IF NOT EXISTS labels_by_entity (
  entity_id TEXT NOT NULL,
  label_id TEXT NOT NULL,

  PRIMARY KEY (entity_id, label_id)
);

insertOrIgnoreLabelByEntity:
INSERT OR IGNORE INTO labels_by_entity
VALUES ?;

deleteLabelLinksByEntity {
DELETE FROM labels_by_entity WHERE entity_id = :entityId;
}

getNumberOfLabelsByEntity:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT label.id)
    FROM labels_by_entity le
    INNER JOIN label ON label.id = le.label_id
    LEFT JOIN label_alias ON label.id = label_alias.label_id AND label_alias.is_primary
    WHERE le.entity_id = :entityId
    AND (
      label.name LIKE :query OR
      label.disambiguation LIKE :query OR
      label.type LIKE :query OR
      label.label_code LIKE :query OR
      label_alias.name LIKE :query
    )
  ),
  0
) AS count;

getLabelsByEntity:
SELECT
  label.id,
  label.name,
  label.disambiguation,
  label.type,
  label.label_code,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = label.id
  ) AS collected,
  GROUP_CONCAT(label_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(label_alias.locale, CHAR(9)) AS alias_locales
FROM labels_by_entity le
INNER JOIN label ON label.id = le.label_id
LEFT JOIN label_alias ON label.id = label_alias.label_id AND label_alias.is_primary
LEFT JOIN details_metadata ON details_metadata.entity_id = label.id
WHERE le.entity_id = :entityId
AND (
  label.name LIKE :query OR
  label.disambiguation LIKE :query OR
  label.type LIKE :query OR
  label.label_code LIKE :query OR
  label_alias.name LIKE :query
)
GROUP BY label.id
LIMIT :limit OFFSET :offset;

-- labels by collection

getNumberOfLabelsByCollection:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT label.id)
    FROM label
    INNER JOIN collection_entity ce ON label.id = ce.entity_id
    INNER JOIN collection c ON c.id = ce.id
    LEFT JOIN label_alias ON label.id = label_alias.label_id AND label_alias.is_primary
    WHERE c.id = :collectionId
    AND ce.deleted = 0
    AND (
      label.name LIKE :query OR
      label.disambiguation LIKE :query OR
      label.type LIKE :query OR
      label.label_code LIKE :query OR
      label_alias.name LIKE :query
    )
  ),
  0
) AS count;

getLabelsByCollection:
SELECT
  label.id,
  label.name,
  label.disambiguation,
  label.type,
  label.label_code,
  details_metadata.entity_id IS NOT NULL AS visited,
  ce.id IS NOT NULL AS collected,
  GROUP_CONCAT(label_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(label_alias.locale, CHAR(9)) AS alias_locales
FROM label label
INNER JOIN collection_entity ce ON label.id = ce.entity_id
INNER JOIN collection c ON c.id = ce.id
LEFT JOIN label_alias ON label.id = label_alias.label_id AND label_alias.is_primary
LEFT JOIN details_metadata ON details_metadata.entity_id = label.id
WHERE c.id = :collectionId
AND ce.deleted = 0
AND (
  label.name LIKE :query OR
  label.disambiguation LIKE :query OR
  label.type LIKE :query OR
  label.label_code LIKE :query OR
  label_alias.name LIKE :query
)
GROUP BY label.id
LIMIT :limit OFFSET :offset;

-- labels by release

getLabelsByRelease:
SELECT
  label.id,
  label.name,
  label.disambiguation,
  label.type,
  label.label_code,
  COALESCE(
    (
      SELECT GROUP_CONCAT(catalog_number, ', ')
      FROM release_label rl
      WHERE rl.release_id = :releaseId
      AND rl.label_id = label.id
      ORDER BY rl.catalog_number
    ),
    ''
  ) AS catalogNumbers,
  details_metadata.entity_id IS NOT NULL AS visited,
  GROUP_CONCAT(label_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(label_alias.locale, CHAR(9)) AS alias_locales
FROM label
INNER JOIN labels_by_entity le ON label.id = le.label_id
LEFT JOIN label_alias ON label.id = label_alias.label_id AND label_alias.is_primary
LEFT JOIN details_metadata ON details_metadata.entity_id = label.id
WHERE le.entity_id = :releaseId
GROUP BY label.id, label.name, label.disambiguation, label.type, label.label_code
ORDER BY label.name;

-- all labels

getCountOfAllLabels:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT label.id)
    FROM label
    LEFT JOIN label_alias ON label.id = label_alias.label_id AND label_alias.is_primary
    WHERE (
      label.name LIKE :query OR
      label.disambiguation LIKE :query OR
      label.type LIKE :query OR
      label.label_code LIKE :query OR
      label_alias.name LIKE :query
    )
  ),
  0
) AS count;

getAllLabels:
SELECT
  label.id,
  label.name,
  label.disambiguation,
  label.type,
  label.label_code,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = label.id
  ) AS collected,
  GROUP_CONCAT(label_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(label_alias.locale, CHAR(9)) AS alias_locales
FROM label
LEFT JOIN label_alias ON label.id = label_alias.label_id AND label_alias.is_primary
LEFT JOIN details_metadata ON details_metadata.entity_id = label.id
WHERE (
  label.name LIKE :query OR
  label.disambiguation LIKE :query OR
  label.type LIKE :query OR
  label.label_code LIKE :query OR
  label_alias.name LIKE :query
)
GROUP BY label.id
LIMIT :limit OFFSET :offset;
