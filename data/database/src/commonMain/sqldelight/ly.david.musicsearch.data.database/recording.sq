import kotlin.Boolean;
import kotlin.Int;
import kotlin.String;
import kotlin.collections.List;

CREATE TABLE recording (
  id TEXT PRIMARY KEY NOT NULL,
  name TEXT NOT NULL,
  disambiguation TEXT NOT NULL,
  first_release_date TEXT NOT NULL,
  length INTEGER AS Int,
  video INTEGER AS Boolean NOT NULL,
  isrcs TEXT AS List<String> NOT NULL
);

insert:
INSERT OR IGNORE INTO recording
VALUES (
  :id,
  :name,
  :disambiguation,
  :firstReleaseDate,
  :length,
  :video,
  :isrcs
);

upsert {
UPDATE recording
SET
  name = :name,
  disambiguation = :disambiguation,
  first_release_date = :firstReleaseDate,
  length = :length,
  video = :video,
  isrcs = :isrcs
WHERE id = :id;

INSERT OR IGNORE INTO recording
VALUES (
  :id,
  :name,
  :disambiguation,
  :firstReleaseDate,
  :length,
  :video,
  :isrcs
);
}

deleteRecording:
DELETE FROM recording
WHERE id = :id;

getRecordingForDetails:
SELECT
  recording.id,
  recording.name,
  recording.disambiguation,
  recording.first_release_date,
  recording.length,
  recording.video,
  recording.isrcs,
  details_metadata.last_updated,
  COUNT(listen.recording_musicbrainz_id) AS listen_count
FROM recording
LEFT JOIN details_metadata ON details_metadata.entity_id = recording.id
LEFT JOIN listen ON listen.recording_musicbrainz_id = recording.id AND listen.username = :username
WHERE recording.id = :recordingId
GROUP BY recording.id;

getLatestListensByRecording:
SELECT
  listened_at_ms
FROM recording
LEFT JOIN listen ON recording.id = listen.recording_musicbrainz_id
WHERE listen.username = :username AND recording.id = :recordingId
ORDER BY listened_at_ms DESC
LIMIT COALESCE(:limit, -1);

-- recordings by entity

CREATE TABLE IF NOT EXISTS recordings_by_entity (
  entity_id TEXT NOT NULL,
  recording_id TEXT NOT NULL,

  PRIMARY KEY (entity_id, recording_id)
);

insertOrIgnoreRecordingByEntity:
INSERT OR IGNORE INTO recordings_by_entity
VALUES ?;

deleteRecordingLinksByEntity {
DELETE FROM recordings_by_entity WHERE entity_id = :entityId;
}

getNumberOfRecordingsByEntity:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT recording.id)
    FROM recordings_by_entity re
    INNER JOIN recording ON recording.id = re.recording_id
    INNER JOIN artist_credit_entity acr ON acr.entity_id = recording.id
    INNER JOIN artist_credit ac ON ac.id = acr.artist_credit_id
    LEFT JOIN recording_alias ON recording.id = recording_alias.recording_id AND recording_alias.is_primary
    WHERE re.entity_id = :entityId
    AND (
      recording.name LIKE :query OR
      recording.disambiguation LIKE :query OR
      recording.first_release_date LIKE :query OR
      ac.name LIKE :query OR
      recording_alias.name LIKE :query
    )
  ),
  0
) AS count;

getRecordingsByEntity:
SELECT
  recording.id,
  recording.name,
  recording.disambiguation,
  recording.first_release_date,
  recording.length,
  recording.video,
  ac.name AS artist_credits,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = recording.id
  ) AS collected,
  aliases.alias_names,
  aliases.alias_locales,
  CASE WHEN :username = '' THEN CAST(NULL AS INTEGER) ELSE COUNT(listen.recording_musicbrainz_id) END AS listen_count
FROM recordings_by_entity re
INNER JOIN recording ON recording.id = re.recording_id
INNER JOIN artist_credit_entity acr ON acr.entity_id = recording.id
INNER JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN (
  SELECT
    recording_alias.recording_id,
    GROUP_CONCAT(recording_alias.name, CHAR(9)) AS alias_names,
    GROUP_CONCAT(recording_alias.locale, CHAR(9)) AS alias_locales
  FROM recording_alias
  WHERE recording_alias.is_primary AND recording_alias.recording_id IN (
    SELECT recording.id
    FROM recording
    INNER JOIN recordings_by_entity ON recording.id = recordings_by_entity.recording_id
    WHERE recordings_by_entity.entity_id = :entityId
  )
  GROUP BY recording_alias.recording_id
) AS aliases ON aliases.recording_id = recording.id
LEFT JOIN details_metadata ON details_metadata.entity_id = recording.id
LEFT JOIN listen ON listen.recording_musicbrainz_id = recording.id AND listen.username = :username
WHERE re.entity_id = :entityId
AND (
  recording.name LIKE :query OR
  recording.disambiguation LIKE :query OR
  recording.first_release_date LIKE :query OR
  ac.name LIKE :query OR
  aliases.alias_names LIKE :query
)
GROUP BY recording.id
ORDER BY
  CASE :sortBy
    WHEN 0 THEN re.rowid
    WHEN 2 THEN recording.name
    WHEN 4 THEN recording.first_release_date
    WHEN 6 THEN listen_count
  END ASC,
  CASE :sortBy
    WHEN 1 THEN re.rowid
    WHEN 3 THEN recording.name
    WHEN 5 THEN recording.first_release_date
    WHEN 7 THEN listen_count
  END DESC,
  recording.first_release_date ASC,
  recording.name ASC
LIMIT :limit OFFSET :offset;

-- recordings by collection

getNumberOfRecordingsByCollection:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT recording.id)
    FROM recording
    INNER JOIN collection_entity ce ON recording.id = ce.entity_id
    INNER JOIN collection c ON c.id = ce.id
    INNER JOIN artist_credit_entity acr ON acr.entity_id = recording.id
    INNER JOIN artist_credit ac ON ac.id = acr.artist_credit_id
    LEFT JOIN recording_alias ON recording.id = recording_alias.recording_id AND recording_alias.is_primary
    WHERE c.id = :collectionId
    AND ce.deleted = 0
    AND (
      recording.name LIKE :query OR
      recording.disambiguation LIKE :query OR
      recording.first_release_date LIKE :query OR
      ac.name LIKE :query OR
      recording_alias.name LIKE :query
    )
  ),
  0
) AS count;

getRecordingsByCollection:
SELECT
  recording.id,
  recording.name,
  recording.disambiguation,
  recording.first_release_date,
  recording.length,
  recording.video,
  ac.name AS artist_credits,
  details_metadata.entity_id IS NOT NULL AS visited,
  ce.id IS NOT NULL AS collected,
  aliases.alias_names,
  aliases.alias_locales,
  CASE WHEN :username = '' THEN CAST(NULL AS INTEGER) ELSE COUNT(listen.recording_musicbrainz_id) END AS listen_count
FROM recording
INNER JOIN collection_entity ce ON recording.id = ce.entity_id
INNER JOIN collection c ON c.id = ce.id
INNER JOIN artist_credit_entity acr ON acr.entity_id = recording.id
INNER JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN (
  SELECT
    recording_alias.recording_id,
    GROUP_CONCAT(recording_alias.name, CHAR(9)) AS alias_names,
    GROUP_CONCAT(recording_alias.locale, CHAR(9)) AS alias_locales
  FROM recording_alias
  WHERE recording_alias.is_primary AND recording_alias.recording_id IN (
    SELECT recording.id
    FROM recording
    INNER JOIN collection_entity ON recording.id = collection_entity.entity_id
    WHERE collection_entity.id = :collectionId
  )
  GROUP BY recording_alias.recording_id
) AS aliases ON aliases.recording_id = recording.id
LEFT JOIN details_metadata ON details_metadata.entity_id = recording.id
LEFT JOIN listen ON listen.recording_musicbrainz_id = recording.id AND listen.username = :username
WHERE c.id = :collectionId
AND ce.deleted = 0
AND (
  recording.name LIKE :query OR
  recording.disambiguation LIKE :query OR
  recording.first_release_date LIKE :query OR
  ac.name LIKE :query OR
  aliases.alias_names LIKE :query
)
GROUP BY recording.id
ORDER BY
  CASE :sortBy
    WHEN 0 THEN ce.rowid
    WHEN 2 THEN recording.name
    WHEN 4 THEN recording.first_release_date
    WHEN 6 THEN listen_count
  END ASC,
  CASE :sortBy
    WHEN 1 THEN ce.rowid
    WHEN 3 THEN recording.name
    WHEN 5 THEN recording.first_release_date
    WHEN 7 THEN listen_count
  END DESC,
  recording.first_release_date ASC,
  recording.name ASC
LIMIT :limit OFFSET :offset;

-- all recordings

getCountOfAllRecordings:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT recording.id)
    FROM recording
    INNER JOIN artist_credit_entity acr ON acr.entity_id = recording.id
    INNER JOIN artist_credit ac ON ac.id = acr.artist_credit_id
    LEFT JOIN recording_alias ON recording.id = recording_alias.recording_id AND recording_alias.is_primary
    WHERE (
      recording.name LIKE :query OR
      recording.disambiguation LIKE :query OR
      recording.first_release_date LIKE :query OR
      ac.name LIKE :query OR
      recording_alias.name LIKE :query
    )
  ),
  0
) AS count;

getAllRecordings:
SELECT
  recording.id,
  recording.name,
  recording.disambiguation,
  recording.first_release_date,
  recording.length,
  recording.video,
  ac.name AS artist_credits,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = recording.id
  ) AS collected,
  aliases.alias_names,
  aliases.alias_locales,
  CASE WHEN :username = '' THEN CAST(NULL AS INTEGER) ELSE COUNT(listen.recording_musicbrainz_id) END AS listen_count
FROM recording
INNER JOIN artist_credit_entity acr ON acr.entity_id = recording.id
INNER JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN (
  SELECT
    recording_alias.recording_id,
    GROUP_CONCAT(recording_alias.name, CHAR(9)) AS alias_names,
    GROUP_CONCAT(recording_alias.locale, CHAR(9)) AS alias_locales
  FROM recording_alias
  WHERE recording_alias.is_primary
  GROUP BY recording_alias.recording_id
) AS aliases ON aliases.recording_id = recording.id
LEFT JOIN details_metadata ON details_metadata.entity_id = recording.id
LEFT JOIN listen ON listen.recording_musicbrainz_id = recording.id AND listen.username = :username
WHERE (
  recording.name LIKE :query OR
  recording.disambiguation LIKE :query OR
  recording.first_release_date LIKE :query OR
  ac.name LIKE :query OR
  aliases.alias_names LIKE :query
)
GROUP BY recording.id
ORDER BY
  CASE :sortBy
    WHEN 0 THEN recording.rowid
    WHEN 2 THEN recording.name
    WHEN 4 THEN recording.first_release_date
    WHEN 6 THEN listen_count
  END ASC,
  CASE :sortBy
    WHEN 1 THEN recording.rowid
    WHEN 3 THEN recording.name
    WHEN 5 THEN recording.first_release_date
    WHEN 7 THEN listen_count
  END DESC,
  recording.first_release_date ASC,
  recording.name ASC
LIMIT :limit OFFSET :offset;
