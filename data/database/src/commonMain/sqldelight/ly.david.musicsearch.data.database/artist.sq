import kotlin.Boolean;
import kotlin.String;
import kotlin.collections.List;

CREATE TABLE artist (
  id TEXT PRIMARY KEY NOT NULL,
  name TEXT NOT NULL,
  sort_name TEXT NOT NULL,
  disambiguation TEXT NOT NULL,
  type TEXT NOT NULL,
  type_id TEXT NOT NULL,
  gender TEXT NOT NULL,
  ipis TEXT AS List<String> NOT NULL,
  isnis TEXT AS List<String> NOT NULL,
  country_code TEXT NOT NULL,
  begin TEXT NOT NULL,
  end TEXT NOT NULL,
  ended INTEGER AS Boolean NOT NULL,
  area_id TEXT NOT NULL
);

upsert {
UPDATE artist
SET
  name = :name,
  sort_name = :sort_name,
  disambiguation = :disambiguation,
  type = :type,
  type_id = :type_id,
  gender = :gender,
  ipis = :ipis,
  isnis = :isnis,
  country_code = :country_code,
  begin = :begin,
  end = :end,
  ended = :ended,
  area_id = :area_id
WHERE id = :id;

INSERT OR IGNORE INTO artist
VALUES (
  :id,
  :name,
  :sort_name,
  :disambiguation,
  :type,
  :type_id,
  :gender,
  :ipis,
  :isnis,
  :country_code,
  :begin,
  :end,
  :ended,
  :area_id
);
}

deleteArtist:
DELETE FROM artist
WHERE id = :artistId;

getArtistForDetails:
SELECT
  artist.id,
  artist.name,
  artist.sort_name,
  artist.disambiguation,
  artist.type,
  artist.gender,
  artist.ipis,
  artist.isnis,
  artist.`begin`,
  artist.`end`,
  artist.ended,
  artist.area_id,
  area.name,
  country_code.code,
  area_details_metadata.entity_id IS NOT NULL AS visitedArea,
  artist_details_metadata.last_updated
FROM artist
LEFT JOIN area ON artist.area_id = area.id
LEFT JOIN country_code ON area.id = country_code.area_id
LEFT JOIN details_metadata area_details_metadata ON area_details_metadata.entity_id = area.id
LEFT JOIN details_metadata artist_details_metadata ON artist_details_metadata.entity_id = artist.id
WHERE artist.id = :artistId
GROUP BY artist.id;

-- artists by entity

CREATE TABLE IF NOT EXISTS artists_by_entity (
  entity_id TEXT NOT NULL,
  artist_id TEXT NOT NULL,

  PRIMARY KEY (entity_id, artist_id)
);

insertOrIgnoreArtistByEntity:
INSERT OR IGNORE INTO artists_by_entity
VALUES ?;

deleteArtistLinksByEntity {
DELETE FROM artists_by_entity WHERE entity_id = :entityId;
}

getNumberOfArtistsByEntity:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT artist.id)
    FROM artists_by_entity ae
    INNER JOIN artist ON artist.id = ae.artist_id
    LEFT JOIN artist_alias ON artist.id = artist_alias.artist_id AND artist_alias.is_primary
    WHERE ae.entity_id = :entityId
    AND (
      artist.name LIKE :query OR
      artist.disambiguation LIKE :query OR
      artist.sort_name LIKE :query OR
      artist.type LIKE :query OR
      artist.gender LIKE :query OR
      artist.country_code LIKE :query OR
      artist_alias.name LIKE :query
    )
  ),
  0
) AS count;

getArtistsByEntity:
SELECT
  artist.id,
  artist.name,
  artist.sort_name,
  artist.disambiguation,
  artist.type,
  artist.gender,
  artist.country_code,
  artist.`begin`,
  artist.`end`,
  artist.ended,
  mi.thumbnail_url,
  mi.id AS imageId,
  EXISTS (
    SELECT 1 FROM details_metadata WHERE details_metadata.entity_id = artist.id
  ) AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = artist.id
  ) AS collected,
  GROUP_CONCAT(artist_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(artist_alias.locale, CHAR(9)) AS alias_locales
FROM artists_by_entity ae
INNER JOIN artist ON artist.id = ae.artist_id
LEFT JOIN artist_alias ON artist.id = artist_alias.artist_id AND artist_alias.is_primary
LEFT JOIN mbid_image mi ON mi.mbid = artist.id
WHERE ae.entity_id = :entityId
AND (
  artist.name LIKE :query OR
  artist.disambiguation LIKE :query OR
  artist.sort_name LIKE :query OR
  artist.type LIKE :query OR
  artist.gender LIKE :query OR
  artist.country_code LIKE :query OR
  artist_alias.name LIKE :query
)
GROUP BY artist.id
LIMIT :limit OFFSET :offset;

-- artists by collection

getNumberOfArtistsByCollection:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT artist.id)
    FROM artist
    INNER JOIN collection_entity ce ON artist.id = ce.entity_id
    INNER JOIN collection c ON c.id = ce.id
    LEFT JOIN artist_alias ON artist.id = artist_alias.artist_id AND artist_alias.is_primary
    WHERE c.id = :collectionId
    AND ce.deleted = 0
    AND (
      artist.name LIKE :query OR
      artist.disambiguation LIKE :query OR
      artist.sort_name LIKE :query OR
      artist.type LIKE :query OR
      artist.gender LIKE :query OR
      artist.country_code LIKE :query
    )
  ),
  0
) AS count;

getArtistsByCollection:
SELECT
  artist.id,
  artist.name,
  artist.sort_name,
  artist.disambiguation,
  artist.type,
  artist.gender,
  artist.country_code,
  artist.`begin`,
  artist.`end`,
  artist.ended,
  mi.thumbnail_url,
  mi.id AS imageId,
  details_metadata.entity_id IS NOT NULL AS visited,
  ce.id IS NOT NULL AS collected,
  GROUP_CONCAT(artist_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(artist_alias.locale, CHAR(9)) AS alias_locales
FROM artist
INNER JOIN collection_entity ce ON artist.id = ce.entity_id
INNER JOIN collection c ON c.id = ce.id
LEFT JOIN artist_alias ON artist.id = artist_alias.artist_id AND artist_alias.is_primary
LEFT JOIN mbid_image mi ON mi.mbid = artist.id
LEFT JOIN details_metadata ON details_metadata.entity_id = artist.id
WHERE c.id = :collectionId
AND ce.deleted = 0
AND (
  artist.name LIKE :query OR
  artist.disambiguation LIKE :query OR
  artist.sort_name LIKE :query OR
  artist.type LIKE :query OR
  artist.gender LIKE :query OR
  artist.country_code LIKE :query OR
  artist_alias.name LIKE :query
)
GROUP BY artist.id
ORDER BY artist.`begin`, artist.`end`, artist.name
LIMIT :limit OFFSET :offset;

-- all artists

getCountOfAllArtists:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT artist.id)
    FROM artist
    LEFT JOIN artist_alias ON artist.id = artist_alias.artist_id AND artist_alias.is_primary
    WHERE (
      artist.name LIKE :query OR
      artist.disambiguation LIKE :query OR
      artist.sort_name LIKE :query OR
      artist.type LIKE :query OR
      artist.gender LIKE :query OR
      artist.country_code LIKE :query OR
      artist_alias.name LIKE :query
    )
  ),
  0
) AS count;

getAllArtists:
SELECT
  artist.id,
  artist.name,
  artist.sort_name,
  artist.disambiguation,
  artist.type,
  artist.gender,
  artist.country_code,
  artist.`begin`,
  artist.`end`,
  artist.ended,
  mi.thumbnail_url,
  mi.id AS imageId,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = artist.id
  ) AS collected,
  GROUP_CONCAT(artist_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(artist_alias.locale, CHAR(9)) AS alias_locales
FROM artist
LEFT JOIN artist_alias ON artist.id = artist_alias.artist_id AND artist_alias.is_primary
LEFT JOIN mbid_image mi ON mi.mbid = artist.id
LEFT JOIN details_metadata ON details_metadata.entity_id = artist.id
WHERE (
  artist.name LIKE :query OR
  artist.disambiguation LIKE :query OR
  artist.sort_name LIKE :query OR
  artist.type LIKE :query OR
  artist.gender LIKE :query OR
  artist.country_code LIKE :query OR
  artist_alias.name LIKE :query
)
GROUP BY artist.id
ORDER BY artist.`begin`, artist.`end`, artist.name
LIMIT :limit OFFSET :offset;

getListenCountByArtist:
SELECT COUNT(*)
FROM artist_credit_name
INNER JOIN artist_credit_entity ON artist_credit_entity.artist_credit_id = artist_credit_name.artist_credit_id
INNER JOIN recording ON recording.id = artist_credit_entity.entity_id
INNER JOIN listen ON listen.recording_musicbrainz_id = recording.id AND listen.username = :username
WHERE artist_credit_name.artist_id = :artistId;
