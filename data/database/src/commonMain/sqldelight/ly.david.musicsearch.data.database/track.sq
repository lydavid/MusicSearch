import kotlin.Int;

CREATE TABLE IF NOT EXISTS track (
  `id` TEXT PRIMARY KEY NOT NULL,
  `medium_id` INTEGER NOT NULL,
  `recording_id` TEXT NOT NULL,
  `position` INTEGER AS Int NOT NULL,
  `number` TEXT NOT NULL,
  `title` TEXT NOT NULL,
  `length` INTEGER AS Int,

  FOREIGN KEY(`medium_id`) REFERENCES `medium`(`id`)
  ON UPDATE CASCADE
  ON DELETE CASCADE
);

insert:
INSERT OR IGNORE INTO track
VALUES ?;

getNumberOfTracksByRelease:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT track.id)
    FROM track
    INNER JOIN medium ON track.medium_id = medium.id
    INNER JOIN `release` r ON medium.release_id = r.id
    INNER JOIN artist_credit_entity acr ON acr.entity_id = track.id
    INNER JOIN artist_credit ac ON ac.id = acr.artist_credit_id
    LEFT JOIN recording_alias ON track.recording_id = recording_alias.recording_id
    WHERE r.id = :releaseId
    AND (
      track.title LIKE :query OR
      track.number LIKE :query OR
      ac.name LIKE :query OR
      recording_alias.name LIKE :query
    )
  ),
  0
) AS count;

getTracksByRelease:
SELECT
  track.id,
  track.medium_id,
  track.recording_id,
  track.position,
  track.number,
  track.title,
  track.length,
  ac.name AS artist_credits,
  details_metadata.entity_id IS NOT NULL AS visited,
  medium.position,
  medium.name,
  medium.track_count,
  medium.format,
  GROUP_CONCAT(recording_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(recording_alias.locale, CHAR(9)) AS alias_locales
FROM track
INNER JOIN medium ON track.medium_id = medium.id
INNER JOIN `release` r ON medium.release_id = r.id
INNER JOIN artist_credit_entity acr ON acr.entity_id = track.id
INNER JOIN artist_credit ac ON ac.id = acr.artist_credit_id
LEFT JOIN details_metadata ON details_metadata.entity_id = track.recording_id
LEFT JOIN recording_alias ON track.recording_id = recording_alias.recording_id
WHERE r.id = :releaseId
AND (
  track.title LIKE :query OR
  track.number LIKE :query OR
  ac.name LIKE :query OR
  recording_alias.name LIKE :query
)
GROUP BY track.id
ORDER BY medium.position, track.position
LIMIT :limit OFFSET :offset;
