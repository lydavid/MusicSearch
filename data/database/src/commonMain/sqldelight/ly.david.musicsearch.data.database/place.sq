import kotlin.Boolean;

CREATE TABLE place (
  id TEXT PRIMARY KEY NOT NULL,
  name TEXT NOT NULL,
  disambiguation TEXT NOT NULL,
  address TEXT NOT NULL,
  type TEXT NOT NULL,
  type_id TEXT NOT NULL,
  longitude REAL,
  latitude REAL,
  begin TEXT NOT NULL,
  end TEXT NOT NULL,
  ended INTEGER AS Boolean NOT NULL
);

insertPlace:
INSERT OR IGNORE INTO place
VALUES ?;

getPlaceForDetails:
SELECT
  id,
  name,
  disambiguation,
  address,
  type,
  longitude,
  latitude,
  begin,
  end,
  ended,
  details_metadata.last_updated
FROM place
LEFT JOIN details_metadata ON details_metadata.entity_id = id
WHERE id = :placeId;

deletePlace:
DELETE FROM place
WHERE id = :id;

-- places by area

-- TODO: rename
-- Reuse this if we need a places_by_entity
CREATE TABLE IF NOT EXISTS area_place (
  area_id TEXT NOT NULL,
  place_id TEXT NOT NULL,

  PRIMARY KEY (area_id, place_id)
);

insertOrIgnoreAreaPlace:
INSERT OR IGNORE INTO area_place
VALUES ?;

deletePlacesByArea {
DELETE FROM area_place WHERE area_id = :areaId;
}

getNumberOfPlacesByArea:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT place.id)
    FROM place
    INNER JOIN area_place ap ON place.id = ap.place_id
    LEFT JOIN place_alias ON place.id = place_alias.place_id AND place_alias.is_primary
    WHERE ap.area_id = :areaId
    AND (
      place.name LIKE :query OR
      place.disambiguation LIKE :query OR
      place.address LIKE :query OR
      place.type LIKE :query OR
      place_alias.name LIKE :query
    )
  ),
  0
) AS count;

getPlacesByArea:
SELECT
  place.id,
  place.name,
  place.disambiguation,
  place.address,
  place.type,
  place.longitude,
  place.latitude,
  place.`begin`,
  place.`end`,
  place.`ended`,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = place.id
  ) AS collected,
  GROUP_CONCAT(place_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(place_alias.locale, CHAR(9)) AS alias_locales
FROM place
INNER JOIN area_place ap ON place.id = ap.place_id
LEFT JOIN place_alias ON place.id = place_alias.place_id AND place_alias.is_primary
LEFT JOIN details_metadata ON details_metadata.entity_id = place.id
WHERE ap.area_id = :areaId
AND (
  place.name LIKE :query OR
  place.disambiguation LIKE :query OR
  place.address LIKE :query OR
  place.type LIKE :query OR
  place_alias.name LIKE :query
)
GROUP BY place.id
ORDER BY place.name, place.address
LIMIT :limit OFFSET :offset;

-- places by collection

getNumberOfPlacesByCollection:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT place.id)
    FROM place
    INNER JOIN collection_entity ce ON place.id = ce.entity_id
    INNER JOIN collection c ON c.id = ce.id
    LEFT JOIN place_alias ON place.id = place_alias.place_id AND place_alias.is_primary
    WHERE c.id = :collectionId
    AND ce.deleted = 0
    AND (
      place.name LIKE :query OR
      place.disambiguation LIKE :query OR
      place.address LIKE :query OR
      place.type LIKE :query OR
      place_alias.name LIKE :query
    )
  ),
  0
) AS count;

getPlacesByCollection:
SELECT
  place.id,
  place.name,
  place.disambiguation,
  place.address,
  place.type,
  place.longitude,
  place.latitude,
  place.`begin`,
  place.`end`,
  place.`ended`,
  details_metadata.entity_id IS NOT NULL AS visited,
  ce.id IS NOT NULL AS collected,
  GROUP_CONCAT(place_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(place_alias.locale, CHAR(9)) AS alias_locales
FROM place
INNER JOIN collection_entity ce ON place.id = ce.entity_id
INNER JOIN collection c ON c.id = ce.id
LEFT JOIN place_alias ON place.id = place_alias.place_id AND place_alias.is_primary
LEFT JOIN details_metadata ON details_metadata.entity_id = place.id
WHERE c.id = :collectionId
AND ce.deleted = 0
AND (
  place.name LIKE :query OR
  place.disambiguation LIKE :query OR
  place.address LIKE :query OR
  place.type LIKE :query OR
  place_alias.name LIKE :query
)
GROUP BY place.id
ORDER BY place.name, place.address
LIMIT :limit OFFSET :offset;

-- all places

getCountOfAllPlaces:
SELECT IFNULL(
  (
    SELECT COUNT(DISTINCT place.id)
    FROM place
    LEFT JOIN place_alias ON place.id = place_alias.place_id
    WHERE (
      place.name LIKE :query OR
      place.disambiguation LIKE :query OR
      place.address LIKE :query OR
      place.type LIKE :query OR
      place_alias.name LIKE :query
    )
  ),
  0
) AS count;

getAllPlaces:
SELECT
  place.id,
  place.name,
  place.disambiguation,
  place.address,
  place.type,
  place.longitude,
  place.latitude,
  place.`begin`,
  place.`end`,
  place.`ended`,
  details_metadata.entity_id IS NOT NULL AS visited,
  EXISTS (
    SELECT 1 FROM collection_entity WHERE collection_entity.entity_id = place.id
  ) AS collected,
  GROUP_CONCAT(place_alias.name, CHAR(9)) AS alias_names,
  GROUP_CONCAT(place_alias.locale, CHAR(9)) AS alias_locales
FROM place
LEFT JOIN place_alias ON place.id = place_alias.place_id AND place_alias.is_primary
LEFT JOIN details_metadata ON details_metadata.entity_id = place.id
WHERE (
  place.name LIKE :query OR
  place.disambiguation LIKE :query OR
  place.address LIKE :query OR
  place.type LIKE :query OR
  place_alias.name LIKE :query
)
GROUP BY place.id
ORDER BY place.name, place.address
LIMIT :limit OFFSET :offset;
